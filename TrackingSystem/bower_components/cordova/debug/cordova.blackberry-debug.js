// Platform: blackberry
// 3.0.0-0-ge670de9
/*
 Licensed to the Apache Software Foundation (ASF) under one
 or more contributor license agreements.  See the NOTICE file
 distributed with this work for additional information
 regarding copyright ownership.  The ASF licenses this file
 to you under the Apache License, Version 2.0 (the
 "License"); you may not use this file except in compliance
 with the License.  You may obtain a copy of the License at
 
     http://www.apache.org/licenses/LICENSE-2.0
 
 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
*/
;(function() {
var CORDOVA_JS_BUILD_LABEL = '3.0.0-0-ge670de9';
try {eval("\nvar require,\n    define;\n\n(function () {\n    var modules = {},\n    // Stack of moduleIds currently being built.\n        requireStack = [],\n    // Map of module ID -> index into requireStack of modules currently being built.\n        inProgressModules = {},\n        SEPERATOR = \".\";\n\n\n\n    function build(module) {\n        var factory = module.factory,\n            localRequire = function (id) {\n                var resultantId = id;\n                //Its a relative path, so lop off the last portion and add the id (minus \"./\")\n                if (id.charAt(0) === \".\") {\n                    resultantId = module.id.slice(0, module.id.lastIndexOf(SEPERATOR)) + SEPERATOR + id.slice(2);\n                }\n                return require(resultantId);\n            };\n        module.exports = {};\n        delete module.factory;\n        factory(localRequire, module.exports, module);\n        return module.exports;\n    }\n\n    require = function (id) {\n        if (!modules[id]) {\n            throw \"module \" + id + \" not found\";\n        } else if (id in inProgressModules) {\n            var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;\n            throw \"Cycle in require graph: \" + cycle;\n        }\n        if (modules[id].factory) {\n            try {\n                inProgressModules[id] = requireStack.length;\n                requireStack.push(id);\n                return build(modules[id]);\n            } finally {\n                delete inProgressModules[id];\n                requireStack.pop();\n            }\n        }\n        return modules[id].exports;\n    };\n\n    define = function (id, factory) {\n        if (modules[id]) {\n            throw \"module \" + id + \" already defined\";\n        }\n\n        modules[id] = {\n            id: id,\n            factory: factory\n        };\n    };\n\n    define.remove = function (id) {\n        delete modules[id];\n    };\n\n    define.moduleMap = modules;\n})();\n\n//Export for use in node\nif (typeof module === \"object\" && typeof require === \"function\") {\n    module.exports.require = require;\n    module.exports.define = define;\n}\n\n//@ sourceURL=lib/scripts/require.js")} catch(e) {console.log("exception: in lib/scripts/require.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova\", function(require, exports, module) {\n\n\nvar channel = require('cordova/channel');\n\n/**\n * Listen for DOMContentLoaded and notify our channel subscribers.\n */\ndocument.addEventListener('DOMContentLoaded', function() {\n    channel.onDOMContentLoaded.fire();\n}, false);\nif (document.readyState == 'complete' || document.readyState == 'interactive') {\n    channel.onDOMContentLoaded.fire();\n}\n\n/**\n * Intercept calls to addEventListener + removeEventListener and handle deviceready,\n * resume, and pause events.\n */\nvar m_document_addEventListener = document.addEventListener;\nvar m_document_removeEventListener = document.removeEventListener;\nvar m_window_addEventListener = window.addEventListener;\nvar m_window_removeEventListener = window.removeEventListener;\n\n/**\n * Houses custom event handlers to intercept on document + window event listeners.\n */\nvar documentEventHandlers = {},\n    windowEventHandlers = {};\n\ndocument.addEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    if (typeof documentEventHandlers[e] != 'undefined') {\n        documentEventHandlers[e].subscribe(handler);\n    } else {\n        m_document_addEventListener.call(document, evt, handler, capture);\n    }\n};\n\nwindow.addEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    if (typeof windowEventHandlers[e] != 'undefined') {\n        windowEventHandlers[e].subscribe(handler);\n    } else {\n        m_window_addEventListener.call(window, evt, handler, capture);\n    }\n};\n\ndocument.removeEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    // If unsubscribing from an event that is handled by a plugin\n    if (typeof documentEventHandlers[e] != \"undefined\") {\n        documentEventHandlers[e].unsubscribe(handler);\n    } else {\n        m_document_removeEventListener.call(document, evt, handler, capture);\n    }\n};\n\nwindow.removeEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    // If unsubscribing from an event that is handled by a plugin\n    if (typeof windowEventHandlers[e] != \"undefined\") {\n        windowEventHandlers[e].unsubscribe(handler);\n    } else {\n        m_window_removeEventListener.call(window, evt, handler, capture);\n    }\n};\n\nfunction createEvent(type, data) {\n    var event = document.createEvent('Events');\n    event.initEvent(type, false, false);\n    if (data) {\n        for (var i in data) {\n            if (data.hasOwnProperty(i)) {\n                event[i] = data[i];\n            }\n        }\n    }\n    return event;\n}\n\nif(typeof window.console === \"undefined\") {\n    window.console = {\n        log:function(){}\n    };\n}\n// there are places in the framework where we call `warn` also, so we should make sure it exists\nif(typeof window.console.warn === \"undefined\") {\n    window.console.warn = function(msg) {\n        this.log(\"warn: \" + msg);\n    }\n}\n\nvar cordova = {\n    define:define,\n    require:require,\n    /**\n     * Methods to add/remove your own addEventListener hijacking on document + window.\n     */\n    addWindowEventHandler:function(event) {\n        return (windowEventHandlers[event] = channel.create(event));\n    },\n    addStickyDocumentEventHandler:function(event) {\n        return (documentEventHandlers[event] = channel.createSticky(event));\n    },\n    addDocumentEventHandler:function(event) {\n        return (documentEventHandlers[event] = channel.create(event));\n    },\n    removeWindowEventHandler:function(event) {\n        delete windowEventHandlers[event];\n    },\n    removeDocumentEventHandler:function(event) {\n        delete documentEventHandlers[event];\n    },\n    /**\n     * Retrieve original event handlers that were replaced by Cordova\n     *\n     * @return object\n     */\n    getOriginalHandlers: function() {\n        return {'document': {'addEventListener': m_document_addEventListener, 'removeEventListener': m_document_removeEventListener},\n        'window': {'addEventListener': m_window_addEventListener, 'removeEventListener': m_window_removeEventListener}};\n    },\n    /**\n     * Method to fire event from native code\n     * bNoDetach is required for events which cause an exception which needs to be caught in native code\n     */\n    fireDocumentEvent: function(type, data, bNoDetach) {\n        var evt = createEvent(type, data);\n        if (typeof documentEventHandlers[type] != 'undefined') {\n            if( bNoDetach ) {\n              documentEventHandlers[type].fire(evt);\n            }\n            else {\n              setTimeout(function() {\n                  // Fire deviceready on listeners that were registered before cordova.js was loaded.\n                  if (type == 'deviceready') {\n                      document.dispatchEvent(evt);\n                  }\n                  documentEventHandlers[type].fire(evt);\n              }, 0);\n            }\n        } else {\n            document.dispatchEvent(evt);\n        }\n    },\n    fireWindowEvent: function(type, data) {\n        var evt = createEvent(type,data);\n        if (typeof windowEventHandlers[type] != 'undefined') {\n            setTimeout(function() {\n                windowEventHandlers[type].fire(evt);\n            }, 0);\n        } else {\n            window.dispatchEvent(evt);\n        }\n    },\n\n    /**\n     * Plugin callback mechanism.\n     */\n    // Randomize the starting callbackId to avoid collisions after refreshing or navigating.\n    // This way, it's very unlikely that any new callback would get the same callbackId as an old callback.\n    callbackId: Math.floor(Math.random() * 2000000000),\n    callbacks:  {},\n    callbackStatus: {\n        NO_RESULT: 0,\n        OK: 1,\n        CLASS_NOT_FOUND_EXCEPTION: 2,\n        ILLEGAL_ACCESS_EXCEPTION: 3,\n        INSTANTIATION_EXCEPTION: 4,\n        MALFORMED_URL_EXCEPTION: 5,\n        IO_EXCEPTION: 6,\n        INVALID_ACTION: 7,\n        JSON_EXCEPTION: 8,\n        ERROR: 9\n    },\n\n    /**\n     * Called by native code when returning successful result from an action.\n     */\n    callbackSuccess: function(callbackId, args) {\n        try {\n            cordova.callbackFromNative(callbackId, true, args.status, [args.message], args.keepCallback);\n        } catch (e) {\n            console.log(\"Error in error callback: \" + callbackId + \" = \"+e);\n        }\n    },\n\n    /**\n     * Called by native code when returning error result from an action.\n     */\n    callbackError: function(callbackId, args) {\n        // TODO: Deprecate callbackSuccess and callbackError in favour of callbackFromNative.\n        // Derive success from status.\n        try {\n            cordova.callbackFromNative(callbackId, false, args.status, [args.message], args.keepCallback);\n        } catch (e) {\n            console.log(\"Error in error callback: \" + callbackId + \" = \"+e);\n        }\n    },\n\n    /**\n     * Called by native code when returning the result from an action.\n     */\n    callbackFromNative: function(callbackId, success, status, args, keepCallback) {\n        var callback = cordova.callbacks[callbackId];\n        if (callback) {\n            if (success && status == cordova.callbackStatus.OK) {\n                callback.success && callback.success.apply(null, args);\n            } else if (!success) {\n                callback.fail && callback.fail.apply(null, args);\n            }\n\n            // Clear callback if not expecting any more results\n            if (!keepCallback) {\n                delete cordova.callbacks[callbackId];\n            }\n        }\n    },\n    addConstructor: function(func) {\n        channel.onCordovaReady.subscribe(function() {\n            try {\n                func();\n            } catch(e) {\n                console.log(\"Failed to run constructor: \" + e);\n            }\n        });\n    }\n};\n\n// Register pause, resume and deviceready channels as events on document.\nchannel.onPause = cordova.addDocumentEventHandler('pause');\nchannel.onResume = cordova.addDocumentEventHandler('resume');\nchannel.onDeviceReady = cordova.addStickyDocumentEventHandler('deviceready');\n\nmodule.exports = cordova;\n\n});\n\n//@ sourceURL=lib/cordova.js")} catch(e) {console.log("exception: in lib/cordova.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/argscheck\", function(require, exports, module) {\n\nvar exec = require('cordova/exec');\nvar utils = require('cordova/utils');\n\nvar moduleExports = module.exports;\n\nvar typeMap = {\n    'A': 'Array',\n    'D': 'Date',\n    'N': 'Number',\n    'S': 'String',\n    'F': 'Function',\n    'O': 'Object'\n};\n\nfunction extractParamName(callee, argIndex) {\n  return (/.*?\\((.*?)\\)/).exec(callee)[1].split(', ')[argIndex];\n}\n\nfunction checkArgs(spec, functionName, args, opt_callee) {\n    if (!moduleExports.enableChecks) {\n        return;\n    }\n    var errMsg = null;\n    var typeName;\n    for (var i = 0; i < spec.length; ++i) {\n        var c = spec.charAt(i),\n            cUpper = c.toUpperCase(),\n            arg = args[i];\n        // Asterix means allow anything.\n        if (c == '*') {\n            continue;\n        }\n        typeName = utils.typeName(arg);\n        if ((arg === null || arg === undefined) && c == cUpper) {\n            continue;\n        }\n        if (typeName != typeMap[cUpper]) {\n            errMsg = 'Expected ' + typeMap[cUpper];\n            break;\n        }\n    }\n    if (errMsg) {\n        errMsg += ', but got ' + typeName + '.';\n        errMsg = 'Wrong type for parameter \"' + extractParamName(opt_callee || args.callee, i) + '\" of ' + functionName + ': ' + errMsg;\n        // Don't log when running unit tests.\n        if (typeof jasmine == 'undefined') {\n            console.error(errMsg);\n        }\n        throw TypeError(errMsg);\n    }\n}\n\nfunction getValue(value, defaultValue) {\n    return value === undefined ? defaultValue : value;\n}\n\nmoduleExports.checkArgs = checkArgs;\nmoduleExports.getValue = getValue;\nmoduleExports.enableChecks = true;\n\n\n});\n\n//@ sourceURL=lib/common/argscheck.js")} catch(e) {console.log("exception: in lib/common/argscheck.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/base64\", function(require, exports, module) {\n\nvar base64 = exports;\n\nbase64.fromArrayBuffer = function(arrayBuffer) {\n  var array = new Uint8Array(arrayBuffer);\n  return uint8ToBase64(array);\n};\n\n//------------------------------------------------------------------------------\n\n/* This code is based on the performance tests at http://jsperf.com/b64tests\n * This 12-bit-at-a-time algorithm was the best performing version on all\n * platforms tested.\n */\n\nvar b64_6bit = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar b64_12bit;\n\nvar b64_12bitTable = function() {\n    b64_12bit = [];\n    for (var i=0; i<64; i++) {\n        for (var j=0; j<64; j++) {\n            b64_12bit[i*64+j] = b64_6bit[i] + b64_6bit[j];\n        }\n    }\n    b64_12bitTable = function() { return b64_12bit; };\n    return b64_12bit;\n}\n\nfunction uint8ToBase64(rawData) {\n    var numBytes = rawData.byteLength;\n    var output=\"\";\n    var segment;\n    var table = b64_12bitTable();\n    for (var i=0;i<numBytes-2;i+=3) {\n        segment = (rawData[i] << 16) + (rawData[i+1] << 8) + rawData[i+2];\n        output += table[segment >> 12];\n        output += table[segment & 0xfff];\n    }\n    if (numBytes - i == 2) {\n        segment = (rawData[i] << 16) + (rawData[i+1] << 8);\n        output += table[segment >> 12];\n        output += b64_6bit[(segment & 0xfff) >> 6];\n        output += '=';\n    } else if (numBytes - i == 1) {\n        segment = (rawData[i] << 16);\n        output += table[segment >> 12];\n        output += '==';\n    }\n    return output;\n}\n\n});\n\n//@ sourceURL=lib/common/base64.js")} catch(e) {console.log("exception: in lib/common/base64.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/builder\", function(require, exports, module) {\n\nvar utils = require('cordova/utils');\n\nfunction each(objects, func, context) {\n    for (var prop in objects) {\n        if (objects.hasOwnProperty(prop)) {\n            func.apply(context, [objects[prop], prop]);\n        }\n    }\n}\n\nfunction clobber(obj, key, value) {\n    exports.replaceHookForTesting(obj, key);\n    obj[key] = value;\n    // Getters can only be overridden by getters.\n    if (obj[key] !== value) {\n        utils.defineGetter(obj, key, function() {\n            return value;\n        });\n    }\n}\n\nfunction assignOrWrapInDeprecateGetter(obj, key, value, message) {\n    if (message) {\n        utils.defineGetter(obj, key, function() {\n            console.log(message);\n            delete obj[key];\n            clobber(obj, key, value);\n            return value;\n        });\n    } else {\n        clobber(obj, key, value);\n    }\n}\n\nfunction include(parent, objects, clobber, merge) {\n    each(objects, function (obj, key) {\n        try {\n          var result = obj.path ? require(obj.path) : {};\n\n          if (clobber) {\n              // Clobber if it doesn't exist.\n              if (typeof parent[key] === 'undefined') {\n                  assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);\n              } else if (typeof obj.path !== 'undefined') {\n                  // If merging, merge properties onto parent, otherwise, clobber.\n                  if (merge) {\n                      recursiveMerge(parent[key], result);\n                  } else {\n                      assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);\n                  }\n              }\n              result = parent[key];\n          } else {\n            // Overwrite if not currently defined.\n            if (typeof parent[key] == 'undefined') {\n              assignOrWrapInDeprecateGetter(parent, key, result, obj.deprecated);\n            } else {\n              // Set result to what already exists, so we can build children into it if they exist.\n              result = parent[key];\n            }\n          }\n\n          if (obj.children) {\n            include(result, obj.children, clobber, merge);\n          }\n        } catch(e) {\n          utils.alert('Exception building cordova JS globals: ' + e + ' for key \"' + key + '\"');\n        }\n    });\n}\n\n/**\n * Merge properties from one object onto another recursively.  Properties from\n * the src object will overwrite existing target property.\n *\n * @param target Object to merge properties into.\n * @param src Object to merge properties from.\n */\nfunction recursiveMerge(target, src) {\n    for (var prop in src) {\n        if (src.hasOwnProperty(prop)) {\n            if (target.prototype && target.prototype.constructor === target) {\n                // If the target object is a constructor override off prototype.\n                clobber(target.prototype, prop, src[prop]);\n            } else {\n                if (typeof src[prop] === 'object' && typeof target[prop] === 'object') {\n                    recursiveMerge(target[prop], src[prop]);\n                } else {\n                    clobber(target, prop, src[prop]);\n                }\n            }\n        }\n    }\n}\n\nexports.buildIntoButDoNotClobber = function(objects, target) {\n    include(target, objects, false, false);\n};\nexports.buildIntoAndClobber = function(objects, target) {\n    include(target, objects, true, false);\n};\nexports.buildIntoAndMerge = function(objects, target) {\n    include(target, objects, true, true);\n};\nexports.recursiveMerge = recursiveMerge;\nexports.assignOrWrapInDeprecateGetter = assignOrWrapInDeprecateGetter;\nexports.replaceHookForTesting = function() {};\n\n});\n\n//@ sourceURL=lib/common/builder.js")} catch(e) {console.log("exception: in lib/common/builder.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/channel\", function(require, exports, module) {\n\nvar utils = require('cordova/utils'),\n    nextGuid = 1;\n\n/**\n * Custom pub-sub \"channel\" that can have functions subscribed to it\n * This object is used to define and control firing of events for\n * cordova initialization, as well as for custom events thereafter.\n *\n * The order of events during page load and Cordova startup is as follows:\n *\n * onDOMContentLoaded*         Internal event that is received when the web page is loaded and parsed.\n * onNativeReady*              Internal event that indicates the Cordova native side is ready.\n * onCordovaReady*             Internal event fired when all Cordova JavaScript objects have been created.\n * onDeviceReady*              User event fired to indicate that Cordova is ready\n * onResume                    User event fired to indicate a start/resume lifecycle event\n * onPause                     User event fired to indicate a pause lifecycle event\n * onDestroy*                  Internal event fired when app is being destroyed (User should use window.onunload event, not this one).\n *\n * The events marked with an * are sticky. Once they have fired, they will stay in the fired state.\n * All listeners that subscribe after the event is fired will be executed right away.\n *\n * The only Cordova events that user code should register for are:\n *      deviceready           Cordova native code is initialized and Cordova APIs can be called from JavaScript\n *      pause                 App has moved to background\n *      resume                App has returned to foreground\n *\n * Listeners can be registered as:\n *      document.addEventListener(\"deviceready\", myDeviceReadyListener, false);\n *      document.addEventListener(\"resume\", myResumeListener, false);\n *      document.addEventListener(\"pause\", myPauseListener, false);\n *\n * The DOM lifecycle events should be used for saving and restoring state\n *      window.onload\n *      window.onunload\n *\n */\n\n/**\n * Channel\n * @constructor\n * @param type  String the channel name\n */\nvar Channel = function(type, sticky) {\n    this.type = type;\n    // Map of guid -> function.\n    this.handlers = {};\n    // 0 = Non-sticky, 1 = Sticky non-fired, 2 = Sticky fired.\n    this.state = sticky ? 1 : 0;\n    // Used in sticky mode to remember args passed to fire().\n    this.fireArgs = null;\n    // Used by onHasSubscribersChange to know if there are any listeners.\n    this.numHandlers = 0;\n    // Function that is called when the first listener is subscribed, or when\n    // the last listener is unsubscribed.\n    this.onHasSubscribersChange = null;\n},\n    channel = {\n        /**\n         * Calls the provided function only after all of the channels specified\n         * have been fired. All channels must be sticky channels.\n         */\n        join: function(h, c) {\n            var len = c.length,\n                i = len,\n                f = function() {\n                    if (!(--i)) h();\n                };\n            for (var j=0; j<len; j++) {\n                if (c[j].state === 0) {\n                    throw Error('Can only use join with sticky channels.');\n                }\n                c[j].subscribe(f);\n            }\n            if (!len) h();\n        },\n        create: function(type) {\n            return channel[type] = new Channel(type, false);\n        },\n        createSticky: function(type) {\n            return channel[type] = new Channel(type, true);\n        },\n\n        /**\n         * cordova Channels that must fire before \"deviceready\" is fired.\n         */\n        deviceReadyChannelsArray: [],\n        deviceReadyChannelsMap: {},\n\n        /**\n         * Indicate that a feature needs to be initialized before it is ready to be used.\n         * This holds up Cordova's \"deviceready\" event until the feature has been initialized\n         * and Cordova.initComplete(feature) is called.\n         *\n         * @param feature {String}     The unique feature name\n         */\n        waitForInitialization: function(feature) {\n            if (feature) {\n                var c = channel[feature] || this.createSticky(feature);\n                this.deviceReadyChannelsMap[feature] = c;\n                this.deviceReadyChannelsArray.push(c);\n            }\n        },\n\n        /**\n         * Indicate that initialization code has completed and the feature is ready to be used.\n         *\n         * @param feature {String}     The unique feature name\n         */\n        initializationComplete: function(feature) {\n            var c = this.deviceReadyChannelsMap[feature];\n            if (c) {\n                c.fire();\n            }\n        }\n    };\n\nfunction forceFunction(f) {\n    if (typeof f != 'function') throw \"Function required as first argument!\";\n}\n\n/**\n * Subscribes the given function to the channel. Any time that\n * Channel.fire is called so too will the function.\n * Optionally specify an execution context for the function\n * and a guid that can be used to stop subscribing to the channel.\n * Returns the guid.\n */\nChannel.prototype.subscribe = function(f, c) {\n    // need a function to call\n    forceFunction(f);\n    if (this.state == 2) {\n        f.apply(c || this, this.fireArgs);\n        return;\n    }\n\n    var func = f,\n        guid = f.observer_guid;\n    if (typeof c == \"object\") { func = utils.close(c, f); }\n\n    if (!guid) {\n        // first time any channel has seen this subscriber\n        guid = '' + nextGuid++;\n    }\n    func.observer_guid = guid;\n    f.observer_guid = guid;\n\n    // Don't add the same handler more than once.\n    if (!this.handlers[guid]) {\n        this.handlers[guid] = func;\n        this.numHandlers++;\n        if (this.numHandlers == 1) {\n            this.onHasSubscribersChange && this.onHasSubscribersChange();\n        }\n    }\n};\n\n/**\n * Unsubscribes the function with the given guid from the channel.\n */\nChannel.prototype.unsubscribe = function(f) {\n    // need a function to unsubscribe\n    forceFunction(f);\n\n    var guid = f.observer_guid,\n        handler = this.handlers[guid];\n    if (handler) {\n        delete this.handlers[guid];\n        this.numHandlers--;\n        if (this.numHandlers === 0) {\n            this.onHasSubscribersChange && this.onHasSubscribersChange();\n        }\n    }\n};\n\n/**\n * Calls all functions subscribed to this channel.\n */\nChannel.prototype.fire = function(e) {\n    var fail = false,\n        fireArgs = Array.prototype.slice.call(arguments);\n    // Apply stickiness.\n    if (this.state == 1) {\n        this.state = 2;\n        this.fireArgs = fireArgs;\n    }\n    if (this.numHandlers) {\n        // Copy the values first so that it is safe to modify it from within\n        // callbacks.\n        var toCall = [];\n        for (var item in this.handlers) {\n            toCall.push(this.handlers[item]);\n        }\n        for (var i = 0; i < toCall.length; ++i) {\n            toCall[i].apply(this, fireArgs);\n        }\n        if (this.state == 2 && this.numHandlers) {\n            this.numHandlers = 0;\n            this.handlers = {};\n            this.onHasSubscribersChange && this.onHasSubscribersChange();\n        }\n    }\n};\n\n\n// defining them here so they are ready super fast!\n// DOM event that is received when the web page is loaded and parsed.\nchannel.createSticky('onDOMContentLoaded');\n\n// Event to indicate the Cordova native side is ready.\nchannel.createSticky('onNativeReady');\n\n// Event to indicate that all Cordova JavaScript objects have been created\n// and it's time to run plugin constructors.\nchannel.createSticky('onCordovaReady');\n\n// Event to indicate that all automatically loaded JS plugins are loaded and ready.\nchannel.createSticky('onPluginsReady');\n\n// Event to indicate that Cordova is ready\nchannel.createSticky('onDeviceReady');\n\n// Event to indicate a resume lifecycle event\nchannel.create('onResume');\n\n// Event to indicate a pause lifecycle event\nchannel.create('onPause');\n\n// Event to indicate a destroy lifecycle event\nchannel.createSticky('onDestroy');\n\n// Channels that must fire before \"deviceready\" is fired.\nchannel.waitForInitialization('onCordovaReady');\nchannel.waitForInitialization('onDOMContentLoaded');\n\nmodule.exports = channel;\n\n});\n\n//@ sourceURL=lib/common/channel.js")} catch(e) {console.log("exception: in lib/common/channel.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/commandProxy\", function(require, exports, module) {\n\n\n// internal map of proxy function\nvar CommandProxyMap = {};\n\nmodule.exports = {\n\n    // example: cordova.commandProxy.add(\"Accelerometer\",{getCurrentAcceleration: function(successCallback, errorCallback, options) {...},...);\n    add:function(id,proxyObj) {\n        console.log(\"adding proxy for \" + id);\n        CommandProxyMap[id] = proxyObj;\n        return proxyObj;\n    },\n\n    // cordova.commandProxy.remove(\"Accelerometer\");\n    remove:function(id) {\n        var proxy = CommandProxyMap[id];\n        delete CommandProxyMap[id];\n        CommandProxyMap[id] = null;\n        return proxy;\n    },\n\n    get:function(service,action) {\n        return ( CommandProxyMap[service] ? CommandProxyMap[service][action] : null );\n    }\n};\n});\n\n//@ sourceURL=lib/common/commandProxy.js")} catch(e) {console.log("exception: in lib/common/commandProxy.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/exec\", function(require, exports, module) {\n\nvar cordova = require('cordova'),\n    platform = require('cordova/platform'),\n    utils = require('cordova/utils');\n\n/**\n * Execute a cordova command.  It is up to the native side whether this action\n * is synchronous or asynchronous.  The native side can return:\n *      Synchronous: PluginResult object as a JSON string\n *      Asynchronous: Empty string \"\"\n * If async, the native side will cordova.callbackSuccess or cordova.callbackError,\n * depending upon the result of the action.\n *\n * @param {Function} success    The success callback\n * @param {Function} fail       The fail callback\n * @param {String} service      The name of the service to use\n * @param {String} action       Action to be run in cordova\n * @param {String[]} [args]     Zero or more arguments to pass to the method\n */\n\nmodule.exports = function(success, fail, service, action, args) {\n    try {\n        var manager = require('cordova/plugin/' + platform.runtime() + '/manager'),\n            v = manager.exec(success, fail, service, action, args);\n\n        // If status is OK, then return value back to caller\n        if (v.status == cordova.callbackStatus.OK) {\n\n            // If there is a success callback, then call it now with returned value\n            if (success) {\n                try {\n                    success(v.message);\n                }\n                catch (e) {\n                    console.log(\"Error in success callback: \"+cordova.callbackId+\" = \"+e);\n                }\n            }\n            return v.message;\n        } else if (v.status == cordova.callbackStatus.NO_RESULT) {\n\n        } else {\n            // If error, then display error\n            console.log(\"Error: Status=\"+v.status+\" Message=\"+v.message);\n\n            // If there is a fail callback, then call it now with returned value\n            if (fail) {\n                try {\n                    fail(v.message);\n                }\n                catch (e) {\n                    console.log(\"Error in error callback: \"+cordova.callbackId+\" = \"+e);\n                }\n            }\n            return null;\n        }\n    } catch (e) {\n        utils.alert(\"Error: \"+e);\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/exec.js")} catch(e) {console.log("exception: in lib/blackberry/exec.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/modulemapper\", function(require, exports, module) {\n\nvar builder = require('cordova/builder'),\n    moduleMap = define.moduleMap,\n    symbolList,\n    deprecationMap;\n\nexports.reset = function() {\n    symbolList = [];\n    deprecationMap = {};\n};\n\nfunction addEntry(strategy, moduleName, symbolPath, opt_deprecationMessage) {\n    if (!(moduleName in moduleMap)) {\n        throw new Error('Module ' + moduleName + ' does not exist.');\n    }\n    symbolList.push(strategy, moduleName, symbolPath);\n    if (opt_deprecationMessage) {\n        deprecationMap[symbolPath] = opt_deprecationMessage;\n    }\n}\n\n// Note: Android 2.3 does have Function.bind().\nexports.clobbers = function(moduleName, symbolPath, opt_deprecationMessage) {\n    addEntry('c', moduleName, symbolPath, opt_deprecationMessage);\n};\n\nexports.merges = function(moduleName, symbolPath, opt_deprecationMessage) {\n    addEntry('m', moduleName, symbolPath, opt_deprecationMessage);\n};\n\nexports.defaults = function(moduleName, symbolPath, opt_deprecationMessage) {\n    addEntry('d', moduleName, symbolPath, opt_deprecationMessage);\n};\n\nexports.runs = function(moduleName) {\n    addEntry('r', moduleName, null);\n};\n\nfunction prepareNamespace(symbolPath, context) {\n    if (!symbolPath) {\n        return context;\n    }\n    var parts = symbolPath.split('.');\n    var cur = context;\n    for (var i = 0, part; part = parts[i]; ++i) {\n        cur = cur[part] = cur[part] || {};\n    }\n    return cur;\n}\n\nexports.mapModules = function(context) {\n    var origSymbols = {};\n    context.CDV_origSymbols = origSymbols;\n    for (var i = 0, len = symbolList.length; i < len; i += 3) {\n        var strategy = symbolList[i];\n        var moduleName = symbolList[i + 1];\n        var module = require(moduleName);\n        // <runs/>\n        if (strategy == 'r') {\n            continue;\n        }\n        var symbolPath = symbolList[i + 2];\n        var lastDot = symbolPath.lastIndexOf('.');\n        var namespace = symbolPath.substr(0, lastDot);\n        var lastName = symbolPath.substr(lastDot + 1);\n\n        var deprecationMsg = symbolPath in deprecationMap ? 'Access made to deprecated symbol: ' + symbolPath + '. ' + deprecationMsg : null;\n        var parentObj = prepareNamespace(namespace, context);\n        var target = parentObj[lastName];\n\n        if (strategy == 'm' && target) {\n            builder.recursiveMerge(target, module);\n        } else if ((strategy == 'd' && !target) || (strategy != 'd')) {\n            if (!(symbolPath in origSymbols)) {\n                origSymbols[symbolPath] = target;\n            }\n            builder.assignOrWrapInDeprecateGetter(parentObj, lastName, module, deprecationMsg);\n        }\n    }\n};\n\nexports.getOriginalSymbol = function(context, symbolPath) {\n    var origSymbols = context.CDV_origSymbols;\n    if (origSymbols && (symbolPath in origSymbols)) {\n        return origSymbols[symbolPath];\n    }\n    var parts = symbolPath.split('.');\n    var obj = context;\n    for (var i = 0; i < parts.length; ++i) {\n        obj = obj && obj[parts[i]];\n    }\n    return obj;\n};\n\nexports.loadMatchingModules = function(matchingRegExp) {\n    for (var k in moduleMap) {\n        if (matchingRegExp.exec(k)) {\n            require(k);\n        }\n    }\n};\n\nexports.reset();\n\n\n});\n\n//@ sourceURL=lib/common/modulemapper.js")} catch(e) {console.log("exception: in lib/common/modulemapper.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/platform\", function(require, exports, module) {\n\nmodule.exports = {\n    id: \"blackberry\",\n    runtime: function () {\n        if (navigator.userAgent.indexOf(\"PlayBook\") > -1) {\n            return 'air';\n        }\n        else if (navigator.userAgent.indexOf(\"BlackBerry\") > -1) {\n            return 'java';\n        }\n        else {\n            console.log(\"Unknown user agent?!?!? defaulting to java\");\n            return 'java';\n        }\n    },\n    initialize: function() {\n        var modulemapper = require('cordova/modulemapper'),\n            platform = require('cordova/plugin/' + this.runtime() + '/platform');\n\n        modulemapper.loadMatchingModules(/cordova.*\\/symbols$/);\n        modulemapper.loadMatchingModules(new RegExp('cordova/.*' + this.runtime() + '/.*bbsymbols$'));\n        modulemapper.mapModules(this.contextObj);\n\n        platform.initialize();\n    },\n    contextObj: this // Used for testing.\n};\n\n});\n\n//@ sourceURL=lib/blackberry/platform.js")} catch(e) {console.log("exception: in lib/blackberry/platform.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/DirectoryEntry\", function(require, exports, module) {\n\nvar DirectoryEntry = require('cordova/plugin/DirectoryEntry'),\n    DirectoryReader = require('cordova/plugin/air/DirectoryReader'),\n    FileEntry = require('cordova/plugin/FileEntry'),\n    FileError = require('cordova/plugin/FileError');\n\nvar validFileRe = new RegExp('^[a-zA-Z][0-9a-zA-Z._ ]*$');\n\nmodule.exports = {\n    createReader : function() {\n        return new DirectoryReader(this.fullPath);\n    },\n    /**\n     * Creates or looks up a directory; override for BlackBerry.\n     *\n     * @param path\n     *            {DOMString} either a relative or absolute path from this\n     *            directory in which to look up or create a directory\n     * @param options\n     *            {Flags} options to create or exclusively create the directory\n     * @param successCallback\n     *            {Function} called with the new DirectoryEntry\n     * @param errorCallback\n     *            {Function} called with a FileError\n     */\n    getDirectory : function(path, options, successCallback, errorCallback) {\n    // create directory if it doesn't exist\n        var create = (options && options.create === true) ? true : false,\n        // if true, causes failure if create is true and path already exists\n        exclusive = (options && options.exclusive === true) ? true : false,\n        // directory exists\n        exists,\n        // create a new DirectoryEntry object and invoke success callback\n        createEntry = function() {\n            var path_parts = path.split('/'),\n                name = path_parts[path_parts.length - 1],\n                dirEntry = new DirectoryEntry(name, path);\n\n            // invoke success callback\n            if (typeof successCallback === 'function') {\n                successCallback(dirEntry);\n            }\n        };\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // invalid path\n        if(!validFileRe.exec(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        // determine if path is relative or absolute\n        if (!path) {\n            fail(FileError.ENCODING_ERR);\n            return;\n        } else if (path.indexOf(this.fullPath) !== 0) {\n            // path does not begin with the fullPath of this directory\n            // therefore, it is relative\n            path = this.fullPath + '/' + path;\n        }\n\n        // determine if directory exists\n        try {\n            // will return true if path exists AND is a directory\n            exists = blackberry.io.dir.exists(path);\n        } catch (e) {\n            // invalid path\n            // TODO this will not work on playbook - need to think how to find invalid urls\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n\n        // path is a directory\n        if (exists) {\n            if (create && exclusive) {\n                // can't guarantee exclusivity\n                fail(FileError.PATH_EXISTS_ERR);\n            } else {\n                // create entry for existing directory\n                createEntry();\n            }\n        }\n        // will return true if path exists AND is a file\n        else if (blackberry.io.file.exists(path)) {\n            // the path is a file\n            fail(FileError.TYPE_MISMATCH_ERR);\n        }\n        // path does not exist, create it\n        else if (create) {\n            try {\n                // directory path must have trailing slash\n                var dirPath = path;\n                if (dirPath.substr(-1) !== '/') {\n                    dirPath += '/';\n                }\n                console.log('creating dir path at: ' + dirPath);\n                blackberry.io.dir.createNewDir(dirPath);\n                createEntry();\n            } catch (eone) {\n                // unable to create directory\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        }\n        // path does not exist, don't create\n        else {\n            // directory doesn't exist\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    },\n\n    /**\n     * Create or look up a file.\n     *\n     * @param path {DOMString}\n     *            either a relative or absolute path from this directory in\n     *            which to look up or create a file\n     * @param options {Flags}\n     *            options to create or exclusively create the file\n     * @param successCallback {Function}\n     *            called with the new FileEntry object\n     * @param errorCallback {Function}\n     *            called with a FileError object if error occurs\n     */\n    getFile : function(path, options, successCallback, errorCallback) {\n        // create file if it doesn't exist\n        var create = (options && options.create === true) ? true : false,\n            // if true, causes failure if create is true and path already exists\n            exclusive = (options && options.exclusive === true) ? true : false,\n            // file exists\n            exists,\n            // create a new FileEntry object and invoke success callback\n            createEntry = function() {\n                var path_parts = path.split('/'),\n                    name = path_parts[path_parts.length - 1],\n                    fileEntry = new FileEntry(name, path);\n\n                // invoke success callback\n                if (typeof successCallback === 'function') {\n                    successCallback(fileEntry);\n                }\n            };\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // invalid path\n        if(!validFileRe.exec(path)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        // determine if path is relative or absolute\n        if (!path) {\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        else if (path.indexOf(this.fullPath) !== 0) {\n            // path does not begin with the fullPath of this directory\n            // therefore, it is relative\n            path = this.fullPath + '/' + path;\n        }\n\n        // determine if file exists\n        try {\n            // will return true if path exists AND is a file\n            exists = blackberry.io.file.exists(path);\n        }\n        catch (e) {\n            // invalid path\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        // path is a file\n        if (exists) {\n            if (create && exclusive) {\n                // can't guarantee exclusivity\n                fail(FileError.PATH_EXISTS_ERR);\n            }\n            else {\n                // create entry for existing file\n                createEntry();\n            }\n        }\n        // will return true if path exists AND is a directory\n        else if (blackberry.io.dir.exists(path)) {\n            // the path is a directory\n            fail(FileError.TYPE_MISMATCH_ERR);\n        }\n        // path does not exist, create it\n        else if (create) {\n            // create empty file\n            var emptyBlob = blackberry.utils.stringToBlob('');\n            blackberry.io.file.saveFile(path,emptyBlob);\n            createEntry();\n        }\n        // path does not exist, don't create\n        else {\n            // file doesn't exist\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    },\n\n    /**\n     * Delete a directory and all of it's contents.\n     *\n     * @param successCallback {Function} called with no parameters\n     * @param errorCallback {Function} called with a FileError\n     */\n    removeRecursively : function(successCallback, errorCallback) {\n        // we're removing THIS directory\n        var path = this.fullPath;\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // attempt to delete directory\n        if (blackberry.io.dir.exists(path)) {\n            // it is an error to attempt to remove the file system root\n            //exec(null, null, \"File\", \"isFileSystemRoot\", [ path ]) === true\n            if (false) {\n                fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n            }\n            else {\n                try {\n                    // delete the directory, setting recursive flag to true\n                    blackberry.io.dir.deleteDirectory(path, true);\n                    if (typeof successCallback === \"function\") {\n                        successCallback();\n                    }\n                } catch (e) {\n                    // permissions don't allow deletion\n                    console.log(e);\n                    fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                }\n            }\n        }\n        // it's a file, not a directory\n        else if (blackberry.io.file.exists(path)) {\n            fail(FileError.TYPE_MISMATCH_ERR);\n        }\n        // not found\n        else {\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/DirectoryEntry.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/DirectoryEntry.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/DirectoryReader\", function(require, exports, module) {\n\nvar FileError = require('cordova/plugin/FileError');\n\n/**\n * An interface that lists the files and directories in a directory.\n */\nfunction DirectoryReader(path) {\n    this.path = path || null;\n}\n\n/**\n * Returns a list of entries from a directory.\n *\n * @param {Function} successCallback is called with a list of entries\n * @param {Function} errorCallback is called with a FileError\n */\nDirectoryReader.prototype.readEntries = function(successCallback, errorCallback) {\n    var win = typeof successCallback !== 'function' ? null : function(result) {\n        var retVal = [];\n        for (var i=0; i<result.length; i++) {\n            var entry = null;\n            if (result[i].isDirectory) {\n                entry = new (require('cordova/plugin/DirectoryEntry'))();\n            }\n            else if (result[i].isFile) {\n                entry = new (require('cordova/plugin/FileEntry'))();\n            }\n            entry.isDirectory = result[i].isDirectory;\n            entry.isFile = result[i].isFile;\n            entry.name = result[i].name;\n            entry.fullPath = result[i].fullPath;\n            retVal.push(entry);\n        }\n        successCallback(retVal);\n    };\n    var fail = typeof errorCallback !== 'function' ? null : function(code) {\n        errorCallback(new FileError(code));\n    };\n\n    var theEntries = [];\n    // Entry object is borked - unable to instantiate a new Entry object so just create one\n    var anEntry = function (isDirectory, name, fullPath) {\n        this.isDirectory = (isDirectory ? true : false);\n        this.isFile = (isDirectory ? false : true);\n        this.name = name;\n        this.fullPath = fullPath;\n    };\n\n    if(blackberry.io.dir.exists(this.path)){\n        var theDirectories = blackberry.io.dir.listDirectories(this.path);\n        var theFiles = blackberry.io.dir.listFiles(this.path);\n\n        var theDirectoriesLength = theDirectories.length;\n        var theFilesLength = theFiles.length;\n        for(var i=0;i<theDirectoriesLength;i++){\n            theEntries.push(new anEntry(true, theDirectories[i], this.path+theDirectories[i]));\n        }\n\n        for(var j=0;j<theFilesLength;j++){\n            theEntries.push(new anEntry(false, theFiles[j], this.path+theFiles[j]));\n        }\n        win(theEntries);\n    }else{\n        fail(FileError.NOT_FOUND_ERR);\n    }\n\n\n};\n\nmodule.exports = DirectoryReader;\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/DirectoryReader.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/DirectoryReader.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/Entry\", function(require, exports, module) {\n\nvar FileError = require('cordova/plugin/FileError'),\n    LocalFileSystem = require('cordova/plugin/LocalFileSystem'),\n    Metadata = require('cordova/plugin/Metadata'),\n    resolveLocalFileSystemURI = require('cordova/plugin/air/resolveLocalFileSystemURI'),\n    DirectoryEntry = require('cordova/plugin/DirectoryEntry'),\n    FileEntry = require('cordova/plugin/FileEntry'),\n    requestFileSystem = require('cordova/plugin/air/requestFileSystem');\n\nvar recursiveCopy = function(srcDirPath, dstDirPath){\n    // get all the contents (file+dir) of the dir\n    var files = blackberry.io.dir.listFiles(srcDirPath);\n    var dirs = blackberry.io.dir.listDirectories(srcDirPath);\n\n    for(var i=0;i<files.length;i++){\n        blackberry.io.file.copy(srcDirPath + '/' + files[i], dstDirPath + '/' + files[i]);\n    }\n\n    for(var j=0;j<dirs.length;j++){\n        if(!blackberry.io.dir.exists(dstDirPath + '/' + dirs[j])){\n            blackberry.io.dir.createNewDir(dstDirPath + '/' + dirs[j]);\n        }\n        recursiveCopy(srcDirPath + '/' + dirs[j], dstDirPath + '/' + dirs[j]);\n    }\n};\n\nvar validFileRe = new RegExp('^[a-zA-Z][0-9a-zA-Z._ ]*$');\n\nmodule.exports = {\n    getMetadata : function(successCallback, errorCallback){\n        var success = typeof successCallback !== 'function' ? null : function(lastModified) {\n          var metadata = new Metadata(lastModified);\n          successCallback(metadata);\n        };\n        var fail = typeof errorCallback !== 'function' ? null : function(code) {\n          errorCallback(new FileError(code));\n        };\n\n        if(this.isFile){\n            if(blackberry.io.file.exists(this.fullPath)){\n                var theFileProperties = blackberry.io.file.getFileProperties(this.fullPath);\n                success(theFileProperties.dateModified);\n            }\n        }else{\n            console.log('Unsupported for directories');\n            fail(FileError.INVALID_MODIFICATION_ERR);\n        }\n    },\n\n    setMetadata : function(successCallback, errorCallback , metadataObject){\n        console.log('setMetadata is unsupported for PlayBook');\n    },\n\n    moveTo : function(parent, newName, successCallback, errorCallback){\n        var fail = function(code) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(code));\n            }\n        };\n        // user must specify parent Entry\n        if (!parent) {\n            fail(FileError.NOT_FOUND_ERR);\n            return;\n        }\n        // source path\n        var srcPath = this.fullPath,\n            // entry name\n            name = newName || this.name,\n            success = function(entry) {\n                if (entry) {\n                    if (typeof successCallback === 'function') {\n                        // create appropriate Entry object\n                        var result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath) : new FileEntry(entry.name, entry.fullPath);\n                        try {\n                            successCallback(result);\n                        }\n                        catch (e) {\n                            console.log('Error invoking callback: ' + e);\n                        }\n                    }\n                }\n                else {\n                    // no Entry object returned\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            };\n\n\n        // Entry object is borked\n        var theEntry = {};\n        var dstPath = parent.fullPath + '/' + name;\n\n        // invalid path\n        if(!validFileRe.exec(name)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        if(this.isFile){\n            if(srcPath != dstPath){\n                if(blackberry.io.file.exists(dstPath)){\n                    blackberry.io.file.deleteFile(dstPath);\n                    blackberry.io.file.copy(srcPath,dstPath);\n                    blackberry.io.file.deleteFile(srcPath);\n\n                    theEntry.fullPath = dstPath;\n                    theEntry.name = name;\n                    theEntry.isDirectory = false;\n                    theEntry.isFile = true;\n                    success(theEntry);\n                }else if(blackberry.io.dir.exists(dstPath)){\n                    // destination path is a directory\n                    fail(FileError.INVALID_MODIFICATION_ERR);\n                }else{\n                    // make sure the directory that we are moving to actually exists\n                    if(blackberry.io.dir.exists(parent.fullPath)){\n                        blackberry.io.file.copy(srcPath,dstPath);\n                        blackberry.io.file.deleteFile(srcPath);\n\n                        theEntry.fullPath = dstPath;\n                        theEntry.name = name;\n                        theEntry.isDirectory = false;\n                        theEntry.isFile = true;\n                        success(theEntry);\n                    }else{\n                        fail(FileError.NOT_FOUND_ERR);\n                    }\n                }\n            }else{\n                // file onto itself\n                fail(FileError.INVALID_MODIFICATION_ERR);\n            }\n        }else{\n            if(srcPath != dstPath){\n                if(blackberry.io.file.exists(dstPath) || srcPath == parent.fullPath){\n                    // destination path is either a file path or moving into parent\n                    fail(FileError.INVALID_MODIFICATION_ERR);\n                }else{\n                    if(!blackberry.io.dir.exists(dstPath)){\n                        blackberry.io.dir.createNewDir(dstPath);\n                        recursiveCopy(srcPath,dstPath);\n                        blackberry.io.dir.deleteDirectory(srcPath, true);\n                        theEntry.fullPath = dstPath;\n                        theEntry.name = name;\n                        theEntry.isDirectory = true;\n                        theEntry.isFile = false;\n                        success(theEntry);\n                    }else{\n                        var numOfEntries = 0;\n                        numOfEntries += blackberry.io.dir.listDirectories(dstPath).length;\n                        numOfEntries += blackberry.io.dir.listFiles(dstPath).length;\n                        if(numOfEntries === 0){\n                            blackberry.io.dir.createNewDir(dstPath);\n                            recursiveCopy(srcPath,dstPath);\n                            blackberry.io.dir.deleteDirectory(srcPath, true);\n                            theEntry.fullPath = dstPath;\n                            theEntry.name = name;\n                            theEntry.isDirectory = true;\n                            theEntry.isFile = false;\n                            success(theEntry);\n                        }else{\n                            // destination directory not empty\n                            fail(FileError.INVALID_MODIFICATION_ERR);\n                        }\n                    }\n                }\n            }else{\n                // directory onto itself\n                fail(FileError.INVALID_MODIFICATION_ERR);\n            }\n        }\n\n    },\n\n    copyTo : function(parent, newName, successCallback, errorCallback) {\n        var fail = function(code) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(code));\n            }\n        };\n        // user must specify parent Entry\n        if (!parent) {\n            fail(FileError.NOT_FOUND_ERR);\n            return;\n        }\n        // source path\n        var srcPath = this.fullPath,\n            // entry name\n            name = newName || this.name,\n            success = function(entry) {\n                if (entry) {\n                    if (typeof successCallback === 'function') {\n                        // create appropriate Entry object\n                        var result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath) : new FileEntry(entry.name, entry.fullPath);\n                        try {\n                            successCallback(result);\n                        }\n                        catch (e) {\n                            console.log('Error invoking callback: ' + e);\n                        }\n                    }\n                }\n                else {\n                    // no Entry object returned\n                    fail(FileError.NOT_FOUND_ERR);\n                }\n            };\n\n        // Entry object is borked\n        var theEntry = {};\n        var dstPath = parent.fullPath + '/' + name;\n\n        // invalid path\n        if(!validFileRe.exec(name)){\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        if(this.isFile){\n            if(srcPath != dstPath){\n                if(blackberry.io.file.exists(dstPath)){\n                    if(blackberry.io.dir.exists(dstPath)){\n                        blackberry.io.file.copy(srcPath,dstPath);\n\n                        theEntry.fullPath = dstPath;\n                        theEntry.name = name;\n                        theEntry.isDirectory = false;\n                        theEntry.isFile = true;\n                        success(theEntry);\n                    }else{\n                        // destination directory doesn't exist\n                        fail(FileError.NOT_FOUND_ERR);\n                    }\n\n                }else{\n                    blackberry.io.file.copy(srcPath,dstPath);\n\n                    theEntry.fullPath = dstPath;\n                    theEntry.name = name;\n                    theEntry.isDirectory = false;\n                    theEntry.isFile = true;\n                    success(theEntry);\n                }\n            }else{\n                // file onto itself\n                fail(FileError.INVALID_MODIFICATION_ERR);\n            }\n        }else{\n            if(srcPath != dstPath){\n                // allow back up to the root but not child dirs\n                if((parent.name != \"root\" && dstPath.indexOf(srcPath)>=0) || blackberry.io.file.exists(dstPath)){\n                    // copying directory into child or is file path\n                    fail(FileError.INVALID_MODIFICATION_ERR);\n                }else{\n                    recursiveCopy(srcPath, dstPath);\n\n                    theEntry.fullPath = dstPath;\n                    theEntry.name = name;\n                    theEntry.isDirectory = true;\n                    theEntry.isFile = false;\n                    success(theEntry);\n                }\n            }else{\n                // directory onto itself\n                fail(FileError.INVALID_MODIFICATION_ERR);\n            }\n        }\n\n    },\n\n    remove : function(successCallback, errorCallback) {\n        var path = this.fullPath,\n            // directory contents\n            contents = [];\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // file\n        if (blackberry.io.file.exists(path)) {\n            try {\n                blackberry.io.file.deleteFile(path);\n                if (typeof successCallback === \"function\") {\n                    successCallback();\n                }\n            } catch (e) {\n                // permissions don't allow\n                fail(FileError.INVALID_MODIFICATION_ERR);\n            }\n        }\n        // directory\n        else if (blackberry.io.dir.exists(path)) {\n            // it is an error to attempt to remove the file system root\n            console.log('entry directory');\n            // TODO: gotta figure out how to get root dirs on playbook -\n            // getRootDirs doesn't work\n            if (false) {\n                fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n            } else {\n                // check to see if directory is empty\n                contents = blackberry.io.dir.listFiles(path);\n                if (contents.length !== 0) {\n                    fail(FileError.INVALID_MODIFICATION_ERR);\n                } else {\n                    try {\n                        // delete\n                        blackberry.io.dir.deleteDirectory(path, false);\n                        if (typeof successCallback === \"function\") {\n                            successCallback();\n                        }\n                    } catch (eone) {\n                        // permissions don't allow\n                        fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                    }\n                }\n            }\n        }\n        // not found\n        else {\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    },\n    getParent : function(successCallback, errorCallback) {\n        var that = this;\n\n        try {\n            // On BlackBerry, the TEMPORARY file system is actually a temporary\n            // directory that is created on a per-application basis. This is\n            // to help ensure that applications do not share the same temporary\n            // space. So we check to see if this is the TEMPORARY file system\n            // (directory). If it is, we must return this Entry, rather than\n            // the Entry for its parent.\n            requestFileSystem(LocalFileSystem.TEMPORARY, 0,\n                    function(fileSystem) {\n                        if (fileSystem.root.fullPath === that.fullPath) {\n                            if (typeof successCallback === 'function') {\n                                successCallback(fileSystem.root);\n                            }\n                        } else {\n                            resolveLocalFileSystemURI(blackberry.io.dir\n                                    .getParentDirectory(that.fullPath),\n                                    successCallback, errorCallback);\n                        }\n                    }, errorCallback);\n        } catch (e) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(FileError.NOT_FOUND_ERR));\n            }\n        }\n    }\n};\n\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/Entry.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/Entry.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/File\", function(require, exports, module) {\n\n/**\n * Constructor.\n * name {DOMString} name of the file, without path information\n * fullPath {DOMString} the full path of the file, including the name\n * type {DOMString} mime type\n * lastModifiedDate {Date} last modified date\n * size {Number} size of the file in bytes\n */\n\nvar File = function(name, fullPath, type, lastModifiedDate, size){\n    this.name = name || '';\n    this.fullPath = fullPath || null;\n    this.type = type || null;\n    this.lastModifiedDate = lastModifiedDate || null;\n    this.size = size || 0;\n};\n\nmodule.exports = File;\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/File.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/File.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/FileEntry\", function(require, exports, module) {\n\nvar FileEntry = require('cordova/plugin/FileEntry'),\n    Entry = require('cordova/plugin/air/Entry'),\n    FileWriter = require('cordova/plugin/air/FileWriter'),\n    File = require('cordova/plugin/air/File'),\n    FileError = require('cordova/plugin/FileError');\n\nmodule.exports = {\n    /**\n     * Creates a new FileWriter associated with the file that this FileEntry represents.\n     *\n     * @param {Function} successCallback is called with the new FileWriter\n     * @param {Function} errorCallback is called with a FileError\n     */\n    createWriter : function(successCallback, errorCallback) {\n        this.file(function(filePointer) {\n            var writer = new FileWriter(filePointer);\n\n            if (writer.fileName === null || writer.fileName === \"\") {\n                if (typeof errorCallback === \"function\") {\n                    errorCallback(new FileError(FileError.INVALID_STATE_ERR));\n                }\n            } else {\n                if (typeof successCallback === \"function\") {\n                    successCallback(writer);\n                }\n            }\n        }, errorCallback);\n    },\n\n    /**\n     * Returns a File that represents the current state of the file that this FileEntry represents.\n     *\n     * @param {Function} successCallback is called with the new File object\n     * @param {Function} errorCallback is called with a FileError\n     */\n    file : function(successCallback, errorCallback) {\n        var win = typeof successCallback !== 'function' ? null : function(f) {\n            var file = new File(f.name, f.fullPath, f.type, f.lastModifiedDate, f.size);\n            successCallback(file);\n        };\n        var fail = typeof errorCallback !== 'function' ? null : function(code) {\n            errorCallback(new FileError(code));\n        };\n\n        if(blackberry.io.file.exists(this.fullPath)){\n            var theFileProperties = blackberry.io.file.getFileProperties(this.fullPath);\n            var theFile = {};\n\n            theFile.fullPath = this.fullPath;\n            theFile.type = theFileProperties.fileExtension;\n            theFile.lastModifiedDate = theFileProperties.dateModified;\n            theFile.size = theFileProperties.size;\n            win(theFile);\n        }else{\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    }\n};\n\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/FileEntry.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/FileEntry.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/FileReader\", function(require, exports, module) {\n\nvar FileError = require('cordova/plugin/FileError'),\n    ProgressEvent = require('cordova/plugin/ProgressEvent');\n\n/**\n * This class reads the mobile device file system.\n *\n * For Android:\n *      The root directory is the root of the file system.\n *      To read from the SD card, the file name is \"sdcard/my_file.txt\"\n * @constructor\n */\nvar FileReader = function() {\n    this.fileName = \"\";\n\n    this.readyState = 0; // FileReader.EMPTY\n\n    // File data\n    this.result = null;\n\n    // Error\n    this.error = null;\n\n    // Event handlers\n    this.onloadstart = null;    // When the read starts.\n    this.onprogress = null;     // While reading (and decoding) file or fileBlob data, and reporting partial file data (progress.loaded/progress.total)\n    this.onload = null;         // When the read has successfully completed.\n    this.onerror = null;        // When the read has failed (see errors).\n    this.onloadend = null;      // When the request has completed (either in success or failure).\n    this.onabort = null;        // When the read has been aborted. For instance, by invoking the abort() method.\n};\n\n// States\nFileReader.EMPTY = 0;\nFileReader.LOADING = 1;\nFileReader.DONE = 2;\n\n/**\n * Abort reading file.\n */\nFileReader.prototype.abort = function() {\n    this.result = null;\n\n    if (this.readyState == FileReader.DONE || this.readyState == FileReader.EMPTY) {\n      return;\n    }\n\n    this.readyState = FileReader.DONE;\n\n    // If abort callback\n    if (typeof this.onabort === 'function') {\n        this.onabort(new ProgressEvent('abort', {target:this}));\n    }\n    // If load end callback\n    if (typeof this.onloadend === 'function') {\n        this.onloadend(new ProgressEvent('loadend', {target:this}));\n    }\n};\n\n/**\n * Read text file.\n *\n * @param file          {File} File object containing file properties\n * @param encoding      [Optional] (see http://www.iana.org/assignments/character-sets)\n */\nFileReader.prototype.readAsText = function(file, encoding) {\n    // Figure out pathing\n    this.fileName = '';\n    if (typeof file.fullPath === 'undefined') {\n        this.fileName = file;\n    } else {\n        this.fileName = file.fullPath;\n    }\n\n    // Already loading something\n    if (this.readyState == FileReader.LOADING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // LOADING state\n    this.readyState = FileReader.LOADING;\n\n    // If loadstart callback\n    if (typeof this.onloadstart === \"function\") {\n        this.onloadstart(new ProgressEvent(\"loadstart\", {target:this}));\n    }\n\n    // Default encoding is UTF-8\n    var enc = encoding ? encoding : \"UTF-8\";\n\n    var me = this;\n    // Read file\n    if(blackberry.io.file.exists(this.fileName)){\n        var theText = '';\n        var getFileContents = function(path,blob){\n            if(blob){\n\n                theText = blackberry.utils.blobToString(blob, enc);\n                me.result = theText;\n\n                if (typeof me.onload === \"function\") {\n                    me.onload(new ProgressEvent(\"load\", {target:me}));\n                }\n\n                me.readyState = FileReader.DONE;\n\n                if (typeof me.onloadend === \"function\") {\n                    me.onloadend(new ProgressEvent(\"loadend\", {target:me}));\n                }\n            }\n        };\n        // setting asynch to off\n        blackberry.io.file.readFile(this.fileName, getFileContents, false);\n\n    }else{\n        // If DONE (cancelled), then don't do anything\n        if (me.readyState === FileReader.DONE) {\n            return;\n        }\n\n        // DONE state\n        me.readyState = FileReader.DONE;\n\n        me.result = null;\n\n        // Save error\n        me.error = new FileError(FileError.NOT_FOUND_ERR);\n\n        // If onerror callback\n        if (typeof me.onerror === \"function\") {\n            me.onerror(new ProgressEvent(\"error\", {target:me}));\n        }\n\n        // If onloadend callback\n        if (typeof me.onloadend === \"function\") {\n            me.onloadend(new ProgressEvent(\"loadend\", {target:me}));\n        }\n    }\n};\n\n\n/**\n * Read file and return data as a base64 encoded data url.\n * A data url is of the form:\n *      data:[<mediatype>][;base64],<data>\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsDataURL = function(file) {\n    this.fileName = \"\";\n    if (typeof file.fullPath === \"undefined\") {\n        this.fileName = file;\n    } else {\n        this.fileName = file.fullPath;\n    }\n\n    // Already loading something\n    if (this.readyState == FileReader.LOADING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // LOADING state\n    this.readyState = FileReader.LOADING;\n\n    // If loadstart callback\n    if (typeof this.onloadstart === \"function\") {\n        this.onloadstart(new ProgressEvent(\"loadstart\", {target:this}));\n    }\n\n    var enc = \"BASE64\";\n\n    var me = this;\n\n    // Read file\n    if(blackberry.io.file.exists(this.fileName)){\n        var theText = '';\n        var getFileContents = function(path,blob){\n            if(blob){\n                theText = blackberry.utils.blobToString(blob, enc);\n                me.result = \"data:text/plain;base64,\" +theText;\n\n                if (typeof me.onload === \"function\") {\n                    me.onload(new ProgressEvent(\"load\", {target:me}));\n                }\n\n                me.readyState = FileReader.DONE;\n\n                if (typeof me.onloadend === \"function\") {\n                    me.onloadend(new ProgressEvent(\"loadend\", {target:me}));\n                }\n            }\n        };\n        // setting asynch to off\n        blackberry.io.file.readFile(this.fileName, getFileContents, false);\n\n    }else{\n        // If DONE (cancelled), then don't do anything\n        if (me.readyState === FileReader.DONE) {\n            return;\n        }\n\n        // DONE state\n        me.readyState = FileReader.DONE;\n\n        me.result = null;\n\n        // Save error\n        me.error = new FileError(FileError.NOT_FOUND_ERR);\n\n        // If onerror callback\n        if (typeof me.onerror === \"function\") {\n            me.onerror(new ProgressEvent(\"error\", {target:me}));\n        }\n\n        // If onloadend callback\n        if (typeof me.onloadend === \"function\") {\n            me.onloadend(new ProgressEvent(\"loadend\", {target:me}));\n        }\n    }\n};\n\n/**\n * Read file and return data as a binary data.\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsBinaryString = function(file) {\n    // TODO - Can't return binary data to browser.\n    console.log('method \"readAsBinaryString\" is not supported at this time.');\n};\n\n/**\n * Read file and return data as a binary data.\n *\n * @param file          {File} File object containing file properties\n */\nFileReader.prototype.readAsArrayBuffer = function(file) {\n    // TODO - Can't return binary data to browser.\n    console.log('This method is not supported at this time.');\n};\n\nmodule.exports = FileReader;\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/FileReader.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/FileReader.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/FileTransfer\", function(require, exports, module) {\n\nvar cordova = require('cordova'),\nFileTransferError = require('cordova/plugin/FileTransferError'),\nFileUploadResult = require('cordova/plugin/FileUploadResult');\n\nvar validURLProtocol = new RegExp('^(https?|ftp):\\/\\/');\n\nfunction getParentPath(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(0, pos + 1);\n}\n\nfunction getFileName(filePath) {\n    var pos = filePath.lastIndexOf('/');\n    return filePath.substring(pos + 1);\n}\n\nmodule.exports = {\n    upload: function (args, win, fail) {\n        var filePath = args[0],\n            server = args[1],\n            fileKey = args[2],\n            fileName = args[3],\n            mimeType = args[4],\n            params = args[5],\n            trustAllHosts = args[6],\n            chunkedMode = args[7],\n            headers = args[8];\n\n        if(!validURLProtocol.exec(server)){\n            return { \"status\" : cordova.callbackStatus.ERROR, \"message\" : new FileTransferError(FileTransferError.INVALID_URL_ERR) };\n        }\n\n        window.resolveLocalFileSystemURI(filePath, fileWin, fail);\n\n        function fileWin(entryObject){\n            blackberry.io.file.readFile(filePath, readWin, false);\n        }\n\n        function readWin(filePath, blobFile){\n            var fd = new FormData();\n\n            fd.append(fileKey, blobFile, fileName);\n            for (var prop in params) {\n                if(params.hasOwnProperty(prop)) {\n                    fd.append(prop, params[prop]);\n                }\n            }\n\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"POST\", server);\n            xhr.onload = function(evt) {\n                if (xhr.status == 200) {\n                    var result = new FileUploadResult();\n                    result.bytesSent = xhr.response.length;\n                    result.responseCode = xhr.status;\n                    result.response = xhr.response;\n                    win(result);\n                } else if (xhr.status == 404) {\n                    fail(new FileTransferError(FileTransferError.INVALID_URL_ERR, null, null, xhr.status));\n                } else if (xhr.status == 403) {\n                    fail(new FileTransferError(FileTransferError.INVALID_URL_ERR, null, null, xhr.status));\n                } else {\n                    fail(new FileTransferError(FileTransferError.CONNECTION_ERR, null, null, xhr.status));\n                }\n            };\n            xhr.ontimeout = function(evt) {\n                fail(new FileTransferError(FileTransferError.CONNECTION_ERR, null, null, xhr.status));\n            };\n\n            if(headers){\n                for(var i in headers){\n                    xhr.setRequestHeader(i, headers[i]);\n                }\n            }\n            xhr.send(fd);\n        }\n\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    },\n\n    download: function(args, win, fail){\n        var url = args[0],\n            filePath = args[1];\n\n        if(!validURLProtocol.exec(url)){\n            return { \"status\" : cordova.callbackStatus.ERROR, \"message\" : new FileTransferError(FileTransferError.INVALID_URL_ERR) };\n        }\n\n        var xhr = new XMLHttpRequest();\n\n        function writeFile(fileEntry) {\n            fileEntry.createWriter(function(writer) {\n                writer.onwriteend = function(evt) {\n                    if (!evt.target.error) {\n                        win(new window.FileEntry(fileEntry.name, fileEntry.toURL()));\n                    } else {\n                        fail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR));\n                    }\n                };\n\n                writer.onerror = function(evt) {\n                    fail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR));\n                };\n\n                var blob = blackberry.utils.stringToBlob(xhr.response);\n                writer.write(blob);\n\n            },\n            function(error) {\n                fail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR));\n            });\n        }\n\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState == xhr.DONE) {\n                if (xhr.status == 200 && xhr.response) {\n                    window.resolveLocalFileSystemURI(getParentPath(filePath), function(dir) {\n                        dir.getFile(getFileName(filePath), {create: true}, writeFile, function(error) {\n                            fail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR));\n                        });\n                    }, function(error) {\n                        fail(new FileTransferError(FileTransferError.FILE_NOT_FOUND_ERR));\n                    });\n                } else if (xhr.status == 404) {\n                    fail(new FileTransferError(FileTransferError.INVALID_URL_ERR, null, null, xhr.status));\n                } else {\n                    fail(new FileTransferError(FileTransferError.CONNECTION_ERR, null, null, xhr.status));\n                }\n            }\n        };\n\n        xhr.open(\"GET\", url, true);\n        xhr.responseType = \"arraybuffer\";\n        xhr.send();\n\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/FileTransfer.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/FileTransfer.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/FileWriter\", function(require, exports, module) {\n\nvar FileError = require('cordova/plugin/FileError'),\n    ProgressEvent = require('cordova/plugin/ProgressEvent');\n\n/**\n * @constructor\n * @param file {File} File object containing file properties\n * @param append if true write to the end of the file, otherwise overwrite the file\n */\nvar FileWriter = function(file) {\n    this.fileName = \"\";\n    this.length = 0;\n    if (file) {\n        this.fileName = file.fullPath || file;\n        this.length = file.size || 0;\n    }\n    // default is to write at the beginning of the file\n    this.position = 0;\n\n    this.readyState = 0; // EMPTY\n\n    this.result = null;\n\n    // Error\n    this.error = null;\n\n    // Event handlers\n    this.onwritestart = null;   // When writing starts\n    this.onprogress = null;     // While writing the file, and reporting partial file data\n    this.onwrite = null;        // When the write has successfully completed.\n    this.onwriteend = null;     // When the request has completed (either in success or failure).\n    this.onabort = null;        // When the write has been aborted. For instance, by invoking the abort() method.\n    this.onerror = null;        // When the write has failed (see errors).\n};\n\n// States\nFileWriter.INIT = 0;\nFileWriter.WRITING = 1;\nFileWriter.DONE = 2;\n\n/**\n * Abort writing file.\n */\nFileWriter.prototype.abort = function() {\n    // check for invalid state\n    if (this.readyState === FileWriter.DONE || this.readyState === FileWriter.INIT) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // set error\n    this.error = new FileError(FileError.ABORT_ERR);\n\n    this.readyState = FileWriter.DONE;\n\n    // If abort callback\n    if (typeof this.onabort === \"function\") {\n        this.onabort(new ProgressEvent(\"abort\", {\"target\":this}));\n    }\n\n    // If write end callback\n    if (typeof this.onwriteend === \"function\") {\n        this.onwriteend(new ProgressEvent(\"writeend\", {\"target\":this}));\n    }\n};\n\n/**\n * Writes data to the file\n *\n * @param text to be written\n */\nFileWriter.prototype.write = function(text) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":me}));\n    }\n\n    var textBlob = blackberry.utils.stringToBlob(text);\n\n    if(blackberry.io.file.exists(this.fileName)){\n\n        var oldText = '';\n        var newText = text;\n\n        var getFileContents = function(path,blob){\n\n            if(blob){\n                oldText = blackberry.utils.blobToString(blob);\n                if(oldText.length>0){\n                    newText = oldText.substr(0,me.position) + text;\n                }\n            }\n\n            var tempFile = me.fileName+'temp';\n            if(blackberry.io.file.exists(tempFile)){\n                blackberry.io.file.deleteFile(tempFile);\n            }\n\n            var newTextBlob = blackberry.utils.stringToBlob(newText);\n\n            // crete a temp file, delete file we are 'overwriting', then rename temp file\n            blackberry.io.file.saveFile(tempFile, newTextBlob);\n            blackberry.io.file.deleteFile(me.fileName);\n            blackberry.io.file.rename(tempFile, me.fileName.split('/').pop());\n\n            me.position = newText.length;\n            me.length = me.position;\n\n            if (typeof me.onwrite === \"function\") {\n                me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n        };\n\n        // setting asynch to off\n        blackberry.io.file.readFile(this.fileName, getFileContents, false);\n\n    }else{\n\n        // file is new so just save it\n        blackberry.io.file.saveFile(this.fileName, textBlob);\n        me.position = text.length;\n        me.length = me.position;\n    }\n\n    me.readyState = FileWriter.DONE;\n\n    if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n    }\n};\n\n/**\n * Moves the file pointer to the location specified.\n *\n * If the offset is a negative number the position of the file\n * pointer is rewound.  If the offset is greater than the file\n * size the position is set to the end of the file.\n *\n * @param offset is the location to move the file pointer to.\n */\nFileWriter.prototype.seek = function(offset) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    if (!offset && offset !== 0) {\n        return;\n    }\n\n    // See back from end of file.\n    if (offset < 0) {\n        this.position = Math.max(offset + this.length, 0);\n    }\n    // Offset is bigger than file size so set position\n    // to the end of the file.\n    else if (offset > this.length) {\n        this.position = this.length;\n    }\n    // Offset is between 0 and file size so set the position\n    // to start writing.\n    else {\n        this.position = offset;\n    }\n};\n\n/**\n * Truncates the file to the size specified.\n *\n * @param size to chop the file at.\n */\nFileWriter.prototype.truncate = function(size) {\n    // Throw an exception if we are already writing a file\n    if (this.readyState === FileWriter.WRITING) {\n        throw new FileError(FileError.INVALID_STATE_ERR);\n    }\n\n    // WRITING state\n    this.readyState = FileWriter.WRITING;\n\n    var me = this;\n\n    // If onwritestart callback\n    if (typeof me.onwritestart === \"function\") {\n        me.onwritestart(new ProgressEvent(\"writestart\", {\"target\":this}));\n    }\n\n    if(blackberry.io.file.exists(this.fileName)){\n\n        var oldText = '';\n        var newText = '';\n\n        var getFileContents = function(path,blob){\n\n            if(blob){\n                oldText = blackberry.utils.blobToString(blob);\n                if(oldText.length>0){\n                    newText = oldText.slice(0,size);\n                }else{\n                    // TODO: throw error\n                }\n            }\n\n            var tempFile = me.fileName+'temp';\n            if(blackberry.io.file.exists(tempFile)){\n                blackberry.io.file.deleteFile(tempFile);\n            }\n\n            var newTextBlob = blackberry.utils.stringToBlob(newText);\n\n            // crete a temp file, delete file we are 'overwriting', then rename temp file\n            blackberry.io.file.saveFile(tempFile, newTextBlob);\n            blackberry.io.file.deleteFile(me.fileName);\n            blackberry.io.file.rename(tempFile, me.fileName.split('/').pop());\n\n            me.position = newText.length;\n            me.length = me.position;\n\n            if (typeof me.onwrite === \"function\") {\n                 me.onwrite(new ProgressEvent(\"write\", {\"target\":me}));\n            }\n        };\n\n        // setting asynch to off - worry about making this all callbacks later\n        blackberry.io.file.readFile(this.fileName, getFileContents, false);\n\n    }else{\n\n        // TODO: file doesn't exist - throw error\n\n    }\n\n    me.readyState = FileWriter.DONE;\n\n    if (typeof me.onwriteend === \"function\") {\n                me.onwriteend(new ProgressEvent(\"writeend\", {\"target\":me}));\n    }\n};\n\nmodule.exports = FileWriter;\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/FileWriter.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/FileWriter.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/battery\", function(require, exports, module) {\n\nvar cordova = require('cordova');\n\nmodule.exports = {\n    start: function (args, win, fail) {\n        // Register one listener to each of the level and state change\n        // events using WebWorks API.\n        blackberry.system.event.deviceBatteryStateChange(function(state) {\n            var me = navigator.battery;\n            // state is either CHARGING or UNPLUGGED\n            if (state === 2 || state === 3) {\n                var info = {\n                    \"level\" : me._level,\n                    \"isPlugged\" : state === 2\n                };\n\n                if (me._isPlugged !== info.isPlugged && typeof win === 'function') {\n                    win(info);\n                }\n            }\n        });\n        blackberry.system.event.deviceBatteryLevelChange(function(level) {\n            var me = navigator.battery;\n            if (level != me._level && typeof win === 'function') {\n                win({'level' : level, 'isPlugged' : me._isPlugged});\n            }\n        });\n\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    },\n    stop: function (args, win, fail) {\n        // Unregister battery listeners.\n        blackberry.system.event.deviceBatteryStateChange(null);\n        blackberry.system.event.deviceBatteryLevelChange(null);\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/battery.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/battery.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/camera\", function(require, exports, module) {\n\nvar cordova = require('cordova');\n\nmodule.exports = {\n    takePicture: function (args, win, fail) {\n        var onCaptured = blackberry.events.registerEventHandler(\"onCaptured\", win),\n            onCameraClosed = blackberry.events.registerEventHandler(\"onCameraClosed\", function () {}),\n            onError = blackberry.events.registerEventHandler(\"onError\", fail),\n            request = new blackberry.transport.RemoteFunctionCall('blackberry/media/camera/takePicture');\n\n        request.addParam(\"onCaptured\", onCaptured);\n        request.addParam(\"onCameraClosed\", onCameraClosed);\n        request.addParam(\"onError\", onError);\n\n        //HACK: this is a sync call due to:\n        //https://github.com/blackberry/WebWorks-TabletOS/issues/51\n        request.makeSyncCall();\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/camera.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/camera.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/capture\", function(require, exports, module) {\n\nvar cordova = require('cordova');\n\nfunction capture(action, win, fail) {\n    var onCaptured = blackberry.events.registerEventHandler(\"onCaptured\", function (path) {\n            var file = blackberry.io.file.getFileProperties(path);\n            win([{\n                fullPath: path,\n                lastModifiedDate: file.dateModified,\n                name: path.replace(file.directory + \"/\", \"\"),\n                size: file.size,\n                type: file.fileExtension\n            }]);\n        }),\n        onCameraClosed = blackberry.events.registerEventHandler(\"onCameraClosed\", function () {}),\n        onError = blackberry.events.registerEventHandler(\"onError\", fail),\n        request = new blackberry.transport.RemoteFunctionCall('blackberry/media/camera/' + action);\n\n    request.addParam(\"onCaptured\", onCaptured);\n    request.addParam(\"onCameraClosed\", onCameraClosed);\n    request.addParam(\"onError\", onError);\n\n    //HACK: this is a sync call due to:\n    //https://github.com/blackberry/WebWorks-TabletOS/issues/51\n    request.makeSyncCall();\n}\n\nmodule.exports = {\n    getSupportedAudioModes: function (args, win, fail) {\n        return {\"status\": cordova.callbackStatus.OK, \"message\": []};\n    },\n    getSupportedImageModes: function (args, win, fail) {\n        return {\"status\": cordova.callbackStatus.OK, \"message\": []};\n    },\n    getSupportedVideoModes: function (args, win, fail) {\n        return {\"status\": cordova.callbackStatus.OK, \"message\": []};\n    },\n    captureImage: function (args, win, fail) {\n        if (args[0].limit > 0) {\n            capture(\"takePicture\", win, fail);\n        }\n        else {\n            win([]);\n        }\n\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    },\n    captureVideo: function (args, win, fail) {\n        if (args[0].limit > 0) {\n            capture(\"takeVideo\", win, fail);\n        }\n        else {\n            win([]);\n        }\n\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    },\n    captureAudio: function (args, win, fail) {\n        var onCaptureAudioWin = function(filePath){\n        // for some reason the filePath is coming back as a string between two double quotes\n        filePath = filePath.slice(1, filePath.length-1);\n            var file = blackberry.io.file.getFileProperties(filePath);\n\n            win([{\n                fullPath: filePath,\n                lastModifiedDate: file.dateModified,\n                name: filePath.replace(file.directory + \"/\", \"\"),\n                size: file.size,\n                type: file.fileExtension\n            }]);\n        };\n\n        var onCaptureAudioFail = function(){\n            fail([]);\n        };\n\n        if (args[0].limit > 0 && args[0].duration){\n            // a sloppy way of creating a uuid since there's no built in date function to get milliseconds since epoch\n            // might be better to instead check files within directory and then figure out the next file name should be\n            // ie, img000 -> img001 though that would take awhile and would add a whole bunch of checks\n            var id = new Date();\n            id = (id.getDay()).toString() + (id.getHours()).toString() + (id.getSeconds()).toString() + (id.getMilliseconds()).toString() + (id.getYear()).toString();\n\n            var fileName = blackberry.io.dir.appDirs.shared.music.path+'/audio'+id+'.wav';\n            blackberry.media.microphone.record(fileName, onCaptureAudioWin, onCaptureAudioFail);\n            // multiple duration by a 1000 since it comes in as seconds\n            setTimeout(blackberry.media.microphone.stop,args[0].duration*1000);\n        }\n        else {\n            win([]);\n        }\n        return {\"status\": cordova.callbackStatus.NO_RESULT, \"message\": \"WebWorks Is On It\"};\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/capture.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/capture.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/device\", function(require, exports, module) {\n\nvar channel = require('cordova/channel'),\n    cordova = require('cordova');\n\n// Tell cordova channel to wait on the CordovaInfoReady event\nchannel.waitForInitialization('onCordovaInfoReady');\n\nmodule.exports = {\n    getDeviceInfo : function(args, win, fail){\n        //Register an event handler for the networkChange event\n        var callback = blackberry.events.registerEventHandler(\"deviceInfo\", function (info) {\n                win({\n                    platform: \"BlackBerry\",\n                    version: info.version,\n                    model: \"PlayBook\",\n                    name: \"PlayBook\", // deprecated: please use device.model\n                    uuid: info.uuid,\n                    cordova: CORDOVA_JS_BUILD_LABEL\n                });\n            }),\n            request = new blackberry.transport.RemoteFunctionCall(\"org/apache/cordova/getDeviceInfo\");\n\n        request.addParam(\"id\", callback);\n        request.makeSyncCall();\n\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"\" };\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/device.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/device.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/file/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.clobbers('cordova/plugin/air/DirectoryReader', 'DirectoryReader');\nmodulemapper.clobbers('cordova/plugin/air/File', 'File');\nmodulemapper.clobbers('cordova/plugin/air/FileReader', 'FileReader');\nmodulemapper.clobbers('cordova/plugin/air/FileWriter', 'FileWriter');\nmodulemapper.clobbers('cordova/plugin/air/requestFileSystem', 'requestFileSystem');\nmodulemapper.clobbers('cordova/plugin/air/resolveLocalFileSystemURI', 'resolveLocalFileSystemURI');\nmodulemapper.merges('cordova/plugin/air/DirectoryEntry', 'DirectoryEntry');\nmodulemapper.merges('cordova/plugin/air/Entry', 'Entry');\nmodulemapper.merges('cordova/plugin/air/FileEntry', 'FileEntry');\n\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/file/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/file/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/manager\", function(require, exports, module) {\n\nvar cordova = require('cordova'),\n    plugins = {\n        'Device' : require('cordova/plugin/air/device'),\n        'Battery' : require('cordova/plugin/air/battery'),\n        'Camera' : require('cordova/plugin/air/camera'),\n        'Logger' : require('cordova/plugin/webworks/logger'),\n        'Media' : require('cordova/plugin/webworks/media'),\n        'Capture' : require('cordova/plugin/air/capture'),\n        'Accelerometer' : require('cordova/plugin/webworks/accelerometer'),\n        'NetworkStatus' : require('cordova/plugin/air/network'),\n        'Notification' : require('cordova/plugin/webworks/notification'),\n        'FileTransfer' : require('cordova/plugin/air/FileTransfer')\n    };\n\nmodule.exports = {\n    addPlugin: function (key, module) {\n        plugins[key] = require(module);\n    },\n    exec: function (win, fail, clazz, action, args) {\n        var result = {\"status\" : cordova.callbackStatus.CLASS_NOT_FOUND_EXCEPTION, \"message\" : \"Class \" + clazz + \" cannot be found\"};\n\n        if (plugins[clazz]) {\n            if (plugins[clazz][action]) {\n                result = plugins[clazz][action](args, win, fail);\n            }\n            else {\n                result = { \"status\" : cordova.callbackStatus.INVALID_ACTION, \"message\" : \"Action not found: \" + action };\n            }\n        }\n\n        return result;\n    },\n    resume: function () {},\n    pause: function () {},\n    destroy: function () {}\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/manager.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/manager.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/network\", function(require, exports, module) {\n\nvar cordova = require('cordova'),\n    connection = require('cordova/plugin/Connection');\n\nmodule.exports = {\n    getConnectionInfo: function (args, win, fail) {\n        var connectionType = connection.NONE,\n            eventType = \"offline\",\n            callbackID,\n            request;\n\n        /**\n         * For PlayBooks, we currently only have WiFi connections, so\n         * return WiFi if there is any access at all.\n         * TODO: update if/when PlayBook gets other connection types...\n         */\n        if (blackberry.system.hasDataCoverage()) {\n            connectionType = connection.WIFI;\n            eventType = \"online\";\n        }\n\n        //Register an event handler for the networkChange event\n        callbackID = blackberry.events.registerEventHandler(\"networkChange\", function (status) {\n            win(status.type);\n        });\n\n        //pass our callback id down to our network extension\n        request = new blackberry.transport.RemoteFunctionCall(\"org/apache/cordova/getConnectionInfo\");\n        request.addParam(\"networkStatusChangedID\", callbackID);\n        request.makeSyncCall();\n\n        return { \"status\": cordova.callbackStatus.OK, \"message\": connectionType};\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/network.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/network.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/platform\", function(require, exports, module) {\n\nmodule.exports = {\n    id: \"playbook\",\n    initialize:function() {}\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/platform.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/platform.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/requestFileSystem\", function(require, exports, module) {\n\nvar DirectoryEntry = require('cordova/plugin/DirectoryEntry'),\nFileError = require('cordova/plugin/FileError'),\nFileSystem = require('cordova/plugin/FileSystem'),\nLocalFileSystem = require('cordova/plugin/LocalFileSystem');\n\n/**\n * Request a file system in which to store application data.\n * @param type  local file system type\n * @param size  indicates how much storage space, in bytes, the application expects to need\n * @param successCallback  invoked with a FileSystem object\n * @param errorCallback  invoked if error occurs retrieving file system\n */\nvar requestFileSystem = function(type, size, successCallback, errorCallback) {\n    var fail = function(code) {\n        if (typeof errorCallback === 'function') {\n            errorCallback(new FileError(code));\n        }\n    };\n\n    if (type < 0 || type > 3) {\n        fail(FileError.SYNTAX_ERR);\n    } else {\n        // if successful, return a FileSystem object\n        var success = function(file_system) {\n            if (file_system) {\n                if (typeof successCallback === 'function') {\n                    successCallback(file_system);\n                }\n            }\n            else {\n                // no FileSystem object returned\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        };\n\n        // guessing the max file size is 2GB - 1 bytes?\n        // https://bdsc.webapps.blackberry.com/native/documentation/com.qnx.doc.neutrino.user_guide/topic/limits_filesystems.html\n\n        if(size>=2147483648){\n            fail(FileError.QUOTA_EXCEEDED_ERR);\n            return;\n        }\n\n\n        var theFileSystem;\n        try{\n            // is there a way to get space for the app that doesn't point to the appDirs folder?\n            if(type==LocalFileSystem.TEMPORARY){\n                theFileSystem = new FileSystem('temporary', new DirectoryEntry('root', blackberry.io.dir.appDirs.app.storage.path));\n            }else if(type==LocalFileSystem.PERSISTENT){\n                theFileSystem = new FileSystem('persistent', new DirectoryEntry('root', blackberry.io.dir.appDirs.app.storage.path));\n            }\n            success(theFileSystem);\n        }catch(e){\n            fail(FileError.SYNTAX_ERR);\n        }\n    }\n};\nmodule.exports = requestFileSystem;\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/requestFileSystem.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/requestFileSystem.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/air/resolveLocalFileSystemURI\", function(require, exports, module) {\n\nvar DirectoryEntry = require('cordova/plugin/DirectoryEntry'),\n    FileEntry = require('cordova/plugin/FileEntry'),\n    FileError = require('cordova/plugin/FileError');\n\n/**\n * Look up file system Entry referred to by local URI.\n * @param {DOMString} uri  URI referring to a local file or directory\n * @param successCallback  invoked with Entry object corresponding to URI\n * @param errorCallback    invoked if error occurs retrieving file system entry\n */\nmodule.exports = function(uri, successCallback, errorCallback) {\n    // error callback\n    var fail = function(error) {\n        if (typeof errorCallback === 'function') {\n            errorCallback(new FileError(error));\n        }\n    };\n    // if successful, return either a file or directory entry\n    var success = function(entry) {\n        var result;\n\n        if (entry) {\n            if (typeof successCallback === 'function') {\n                // create appropriate Entry object\n                result = (entry.isDirectory) ? new DirectoryEntry(entry.name, entry.fullPath) : new FileEntry(entry.name, entry.fullPath);\n                try {\n                    successCallback(result);\n                }\n                catch (e) {\n                    console.log('Error invoking callback: ' + e);\n                }\n            }\n        }\n        else {\n            // no Entry object returned\n            fail(FileError.NOT_FOUND_ERR);\n            return;\n        }\n    };\n\n    if(!uri || uri === \"\"){\n        fail(FileError.NOT_FOUND_ERR);\n        return;\n    }\n\n    // decode uri if % char found\n    if(uri.indexOf('%')>=0){\n        uri = decodeURI(uri);\n    }\n\n    // pop the parameters if any\n    if(uri.indexOf('?')>=0){\n        uri = uri.split('?')[0];\n    }\n\n    // check for leading /\n    if(uri.indexOf('/')===0){\n        fail(FileError.ENCODING_ERR);\n        return;\n    }\n\n    // Entry object is borked - unable to instantiate a new Entry object so just create one\n    var theEntry = {};\n    if(blackberry.io.dir.exists(uri)){\n        theEntry.isDirectory = true;\n        theEntry.name = uri.split('/').pop();\n        theEntry.fullPath = uri;\n\n        success(theEntry);\n    }else if(blackberry.io.file.exists(uri)){\n        theEntry.isDirectory = false;\n        theEntry.name = uri.split('/').pop();\n        theEntry.fullPath = uri;\n        success(theEntry);\n        return;\n    }else{\n        fail(FileError.NOT_FOUND_ERR);\n        return;\n    }\n\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/air/resolveLocalFileSystemURI.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/air/resolveLocalFileSystemURI.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/echo\", function(require, exports, module) {\n\nvar exec = require('cordova/exec'),\n    utils = require('cordova/utils');\n\n/**\n * Sends the given message through exec() to the Echo plugin, which sends it back to the successCallback.\n * @param successCallback  invoked with a FileSystem object\n * @param errorCallback  invoked if error occurs retrieving file system\n * @param message  The string to be echoed.\n * @param forceAsync  Whether to force an async return value (for testing native->js bridge).\n */\nmodule.exports = function(successCallback, errorCallback, message, forceAsync) {\n    var action = 'echo';\n    var messageIsMultipart = (utils.typeName(message) == \"Array\");\n    var args = messageIsMultipart ? message : [message];\n\n    if (utils.typeName(message) == 'ArrayBuffer') {\n        if (forceAsync) {\n            console.warn('Cannot echo ArrayBuffer with forced async, falling back to sync.');\n        }\n        action += 'ArrayBuffer';\n    } else if (messageIsMultipart) {\n        if (forceAsync) {\n            console.warn('Cannot echo MultiPart Array with forced async, falling back to sync.');\n        }\n        action += 'MultiPart';\n    } else if (forceAsync) {\n        action += 'Async';\n    }\n\n    exec(successCallback, errorCallback, \"Echo\", action, args);\n};\n\n\n});\n\n//@ sourceURL=lib/common/plugin/echo.js")} catch(e) {console.log("exception: in lib/common/plugin/echo.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/Contact\", function(require, exports, module) {\n\nvar ContactError = require('cordova/plugin/ContactError'),\n    ContactUtils = require('cordova/plugin/java/ContactUtils'),\n    utils = require('cordova/utils'),\n    ContactAddress = require('cordova/plugin/ContactAddress'),\n    exec = require('cordova/exec');\n\n// ------------------\n// Utility functions\n// ------------------\n\n/**\n * Retrieves a BlackBerry contact from the device by unique id.\n *\n * @param uid\n *            Unique id of the contact on the device\n * @return {blackberry.pim.Contact} BlackBerry contact or null if contact with\n *         specified id is not found\n */\nvar findByUniqueId = function(uid) {\n    if (!uid) {\n        return null;\n    }\n    var bbContacts = blackberry.pim.Contact.find(new blackberry.find.FilterExpression(\"uid\", \"==\", uid));\n    return bbContacts[0] || null;\n};\n\n/**\n * Creates a BlackBerry contact object from the W3C Contact object and persists\n * it to device storage.\n *\n * @param {Contact}\n *            contact The contact to save\n * @return a new contact object with all properties set\n */\nvar saveToDevice = function(contact) {\n\n    if (!contact) {\n        return;\n    }\n\n    var bbContact = null;\n    var update = false;\n\n    // if the underlying BlackBerry contact already exists, retrieve it for\n    // update\n    if (contact.id) {\n        // we must attempt to retrieve the BlackBerry contact from the device\n        // because this may be an update operation\n        bbContact = findByUniqueId(contact.id);\n    }\n\n    // contact not found on device, create a new one\n    if (!bbContact) {\n        bbContact = new blackberry.pim.Contact();\n    }\n    // update the existing contact\n    else {\n        update = true;\n    }\n\n    // NOTE: The user may be working with a partial Contact object, because only\n    // user-specified Contact fields are returned from a find operation (blame\n    // the W3C spec). If this is an update to an existing Contact, we don't\n    // want to clear an attribute from the contact database simply because the\n    // Contact object that the user passed in contains a null value for that\n    // attribute. So we only copy the non-null Contact attributes to the\n    // BlackBerry contact object before saving.\n    //\n    // This means that a user must explicitly set a Contact attribute to a\n    // non-null value in order to update it in the contact database.\n    //\n    // name\n    if (contact.name !== null) {\n        if (contact.name.givenName) {\n            bbContact.firstName = contact.name.givenName;\n        }\n        if (contact.name.familyName) {\n            bbContact.lastName = contact.name.familyName;\n        }\n        if (contact.name.honorificPrefix) {\n            bbContact.title = contact.name.honorificPrefix;\n        }\n    }\n\n    // display name\n    if (contact.displayName !== null) {\n        bbContact.user1 = contact.displayName;\n    }\n\n    // note\n    if (contact.note !== null) {\n        bbContact.note = contact.note;\n    }\n\n    // birthday\n    //\n    // user may pass in Date object or a string representation of a date\n    // if it is a string, we don't know the date format, so try to create a\n    // new Date with what we're given\n    //\n    // NOTE: BlackBerry's Date.parse() does not work well, so use new Date()\n    //\n    if (contact.birthday !== null) {\n        if (utils.isDate(contact.birthday)) {\n            bbContact.birthday = contact.birthday;\n        } else {\n            var bday = contact.birthday.toString();\n            bbContact.birthday = (bday.length > 0) ? new Date(bday) : \"\";\n        }\n    }\n\n    // BlackBerry supports three email addresses\n    if (contact.emails && utils.isArray(contact.emails)) {\n\n        // if this is an update, re-initialize email addresses\n        if (update) {\n            bbContact.email1 = \"\";\n            bbContact.email2 = \"\";\n            bbContact.email3 = \"\";\n        }\n\n        // copy the first three email addresses found\n        var email = null;\n        for ( var i = 0; i < contact.emails.length; i += 1) {\n            email = contact.emails[i];\n            if (!email || !email.value) {\n                continue;\n            }\n            if (bbContact.email1 === \"\") {\n                bbContact.email1 = email.value;\n            } else if (bbContact.email2 === \"\") {\n                bbContact.email2 = email.value;\n            } else if (bbContact.email3 === \"\") {\n                bbContact.email3 = email.value;\n            }\n        }\n    }\n\n    // BlackBerry supports a finite number of phone numbers\n    // copy into appropriate fields based on type\n    if (contact.phoneNumbers && utils.isArray(contact.phoneNumbers)) {\n\n        // if this is an update, re-initialize phone numbers\n        if (update) {\n            bbContact.homePhone = \"\";\n            bbContact.homePhone2 = \"\";\n            bbContact.workPhone = \"\";\n            bbContact.workPhone2 = \"\";\n            bbContact.mobilePhone = \"\";\n            bbContact.faxPhone = \"\";\n            bbContact.pagerPhone = \"\";\n            bbContact.otherPhone = \"\";\n        }\n\n        var type = null;\n        var number = null;\n        for ( var j = 0; j < contact.phoneNumbers.length; j += 1) {\n            if (!contact.phoneNumbers[j] || !contact.phoneNumbers[j].value) {\n                continue;\n            }\n            type = contact.phoneNumbers[j].type;\n            number = contact.phoneNumbers[j].value;\n            if (type === 'home') {\n                if (bbContact.homePhone === \"\") {\n                    bbContact.homePhone = number;\n                } else if (bbContact.homePhone2 === \"\") {\n                    bbContact.homePhone2 = number;\n                }\n            } else if (type === 'work') {\n                if (bbContact.workPhone === \"\") {\n                    bbContact.workPhone = number;\n                } else if (bbContact.workPhone2 === \"\") {\n                    bbContact.workPhone2 = number;\n                }\n            } else if (type === 'mobile' && bbContact.mobilePhone === \"\") {\n                bbContact.mobilePhone = number;\n            } else if (type === 'fax' && bbContact.faxPhone === \"\") {\n                bbContact.faxPhone = number;\n            } else if (type === 'pager' && bbContact.pagerPhone === \"\") {\n                bbContact.pagerPhone = number;\n            } else if (bbContact.otherPhone === \"\") {\n                bbContact.otherPhone = number;\n            }\n        }\n    }\n\n    // BlackBerry supports two addresses: home and work\n    // copy the first two addresses found from Contact\n    if (contact.addresses && utils.isArray(contact.addresses)) {\n\n        // if this is an update, re-initialize addresses\n        if (update) {\n            bbContact.homeAddress = null;\n            bbContact.workAddress = null;\n        }\n\n        var address = null;\n        var bbHomeAddress = null;\n        var bbWorkAddress = null;\n        for ( var k = 0; k < contact.addresses.length; k += 1) {\n            address = contact.addresses[k];\n            if (!address || address.id === undefined || address.pref === undefined || address.type === undefined || address.formatted === undefined) {\n                continue;\n            }\n\n            if (bbHomeAddress === null && (!address.type || address.type === \"home\")) {\n                bbHomeAddress = createBlackBerryAddress(address);\n                bbContact.homeAddress = bbHomeAddress;\n            } else if (bbWorkAddress === null && (!address.type || address.type === \"work\")) {\n                bbWorkAddress = createBlackBerryAddress(address);\n                bbContact.workAddress = bbWorkAddress;\n            }\n        }\n    }\n\n    // copy first url found to BlackBerry 'webpage' field\n    if (contact.urls && utils.isArray(contact.urls)) {\n\n        // if this is an update, re-initialize web page\n        if (update) {\n            bbContact.webpage = \"\";\n        }\n\n        var url = null;\n        for ( var m = 0; m < contact.urls.length; m += 1) {\n            url = contact.urls[m];\n            if (!url || !url.value) {\n                continue;\n            }\n            if (bbContact.webpage === \"\") {\n                bbContact.webpage = url.value;\n                break;\n            }\n        }\n    }\n\n    // copy fields from first organization to the\n    // BlackBerry 'company' and 'jobTitle' fields\n    if (contact.organizations && utils.isArray(contact.organizations)) {\n\n        // if this is an update, re-initialize org attributes\n        if (update) {\n            bbContact.company = \"\";\n        }\n\n        var org = null;\n        for ( var n = 0; n < contact.organizations.length; n += 1) {\n            org = contact.organizations[n];\n            if (!org) {\n                continue;\n            }\n            if (bbContact.company === \"\") {\n                bbContact.company = org.name || \"\";\n                bbContact.jobTitle = org.title || \"\";\n                break;\n            }\n        }\n    }\n\n    // categories\n    if (contact.categories && utils.isArray(contact.categories)) {\n        bbContact.categories = [];\n        var category = null;\n        for ( var o = 0; o < contact.categories.length; o += 1) {\n            category = contact.categories[o];\n            if (typeof category == \"string\") {\n                bbContact.categories.push(category);\n            }\n        }\n    }\n\n    // save to device\n    bbContact.save();\n\n    // invoke native side to save photo\n    // fail gracefully if photo URL is no good, but log the error\n    if (contact.photos && utils.isArray(contact.photos)) {\n        var photo = null;\n        for ( var p = 0; p < contact.photos.length; p += 1) {\n            photo = contact.photos[p];\n            if (!photo || !photo.value) {\n                continue;\n            }\n            exec(\n            // success\n            function() {\n            },\n            // fail\n            function(e) {\n                console.log('Contact.setPicture failed:' + e);\n            }, \"Contacts\", \"setPicture\", [ bbContact.uid, photo.type,\n                    photo.value ]);\n            break;\n        }\n    }\n\n    // Use the fully populated BlackBerry contact object to create a\n    // corresponding W3C contact object.\n    return ContactUtils.createContact(bbContact, [ \"*\" ]);\n};\n\n/**\n * Creates a BlackBerry Address object from a W3C ContactAddress.\n *\n * @return {blackberry.pim.Address} a BlackBerry address object\n */\nvar createBlackBerryAddress = function(address) {\n    var bbAddress = new blackberry.pim.Address();\n\n    if (!address) {\n        return bbAddress;\n    }\n\n    bbAddress.address1 = address.streetAddress || \"\";\n    bbAddress.city = address.locality || \"\";\n    bbAddress.stateProvince = address.region || \"\";\n    bbAddress.zipPostal = address.postalCode || \"\";\n    bbAddress.country = address.country || \"\";\n\n    return bbAddress;\n};\n\nmodule.exports = {\n    /**\n     * Persists contact to device storage.\n     */\n    save : function(success, fail) {\n        try {\n            // save the contact and store it's unique id\n            var fullContact = saveToDevice(this);\n            this.id = fullContact.id;\n\n            // This contact object may only have a subset of properties\n            // if the save was an update of an existing contact. This is\n            // because the existing contact was likely retrieved using a\n            // subset of properties, so only those properties were set in the\n            // object. For this reason, invoke success with the contact object\n            // returned by saveToDevice since it is fully populated.\n            if (typeof success === 'function') {\n                success(fullContact);\n            }\n        } catch (e) {\n            console.log('Error saving contact: ' + e);\n            if (typeof fail === 'function') {\n                fail(new ContactError(ContactError.UNKNOWN_ERROR));\n            }\n        }\n    },\n\n    /**\n     * Removes contact from device storage.\n     *\n     * @param success\n     *            success callback\n     * @param fail\n     *            error callback\n     */\n    remove : function(success, fail) {\n        try {\n            // retrieve contact from device by id\n            var bbContact = null;\n            if (this.id) {\n                bbContact = findByUniqueId(this.id);\n            }\n\n            // if contact was found, remove it\n            if (bbContact) {\n                console.log('removing contact: ' + bbContact.uid);\n                bbContact.remove();\n                if (typeof success === 'function') {\n                    success(this);\n                }\n            }\n            // attempting to remove a contact that hasn't been saved\n            else if (typeof fail === 'function') {\n                fail(new ContactError(ContactError.UNKNOWN_ERROR));\n            }\n        } catch (e) {\n            console.log('Error removing contact ' + this.id + \": \" + e);\n            if (typeof fail === 'function') {\n                fail(new ContactError(ContactError.UNKNOWN_ERROR));\n            }\n        }\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/Contact.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/Contact.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/ContactUtils\", function(require, exports, module) {\n\nvar ContactAddress = require('cordova/plugin/ContactAddress'),\n    ContactName = require('cordova/plugin/ContactName'),\n    ContactField = require('cordova/plugin/ContactField'),\n    ContactOrganization = require('cordova/plugin/ContactOrganization'),\n    utils = require('cordova/utils'),\n    Contact = require('cordova/plugin/Contact');\n\n/**\n * Mappings for each Contact field that may be used in a find operation. Maps\n * W3C Contact fields to one or more fields in a BlackBerry contact object.\n *\n * Example: user searches with a filter on the Contact 'name' field:\n *\n * <code>Contacts.find(['name'], onSuccess, onFail, {filter:'Bob'});</code>\n *\n * The 'name' field does not exist in a BlackBerry contact. Instead, a filter\n * expression will be built to search the BlackBerry contacts using the\n * BlackBerry 'title', 'firstName' and 'lastName' fields.\n */\nvar fieldMappings = {\n    \"id\" : \"uid\",\n    \"displayName\" : \"user1\",\n    \"name\" : [ \"title\", \"firstName\", \"lastName\" ],\n    \"name.formatted\" : [ \"title\", \"firstName\", \"lastName\" ],\n    \"name.givenName\" : \"firstName\",\n    \"name.familyName\" : \"lastName\",\n    \"name.honorificPrefix\" : \"title\",\n    \"phoneNumbers\" : [ \"faxPhone\", \"homePhone\", \"homePhone2\", \"mobilePhone\",\n            \"pagerPhone\", \"otherPhone\", \"workPhone\", \"workPhone2\" ],\n    \"phoneNumbers.value\" : [ \"faxPhone\", \"homePhone\", \"homePhone2\",\n            \"mobilePhone\", \"pagerPhone\", \"otherPhone\", \"workPhone\",\n            \"workPhone2\" ],\n    \"emails\" : [ \"email1\", \"email2\", \"email3\" ],\n    \"addresses\" : [ \"homeAddress.address1\", \"homeAddress.address2\",\n            \"homeAddress.city\", \"homeAddress.stateProvince\",\n            \"homeAddress.zipPostal\", \"homeAddress.country\",\n            \"workAddress.address1\", \"workAddress.address2\", \"workAddress.city\",\n            \"workAddress.stateProvince\", \"workAddress.zipPostal\",\n            \"workAddress.country\" ],\n    \"addresses.formatted\" : [ \"homeAddress.address1\", \"homeAddress.address2\",\n            \"homeAddress.city\", \"homeAddress.stateProvince\",\n            \"homeAddress.zipPostal\", \"homeAddress.country\",\n            \"workAddress.address1\", \"workAddress.address2\", \"workAddress.city\",\n            \"workAddress.stateProvince\", \"workAddress.zipPostal\",\n            \"workAddress.country\" ],\n    \"addresses.streetAddress\" : [ \"homeAddress.address1\",\n            \"homeAddress.address2\", \"workAddress.address1\",\n            \"workAddress.address2\" ],\n    \"addresses.locality\" : [ \"homeAddress.city\", \"workAddress.city\" ],\n    \"addresses.region\" : [ \"homeAddress.stateProvince\",\n            \"workAddress.stateProvince\" ],\n    \"addresses.country\" : [ \"homeAddress.country\", \"workAddress.country\" ],\n    \"organizations\" : [ \"company\", \"jobTitle\" ],\n    \"organizations.name\" : \"company\",\n    \"organizations.title\" : \"jobTitle\",\n    \"birthday\" : \"birthday\",\n    \"note\" : \"note\",\n    \"categories\" : \"categories\",\n    \"urls\" : \"webpage\",\n    \"urls.value\" : \"webpage\"\n};\n\n/*\n * Build an array of all of the valid W3C Contact fields. This is used to\n * substitute all the fields when [\"*\"] is specified.\n */\nvar allFields = [];\nfor ( var key in fieldMappings) {\n    if (fieldMappings.hasOwnProperty(key)) {\n        allFields.push(key);\n    }\n}\n\n/**\n * Create a W3C ContactAddress object from a BlackBerry Address object.\n *\n * @param {String}\n *            type the type of address (e.g. work, home)\n * @param {blackberry.pim.Address}\n *            bbAddress a BlackBerry Address object\n * @return {ContactAddress} a contact address object or null if the specified\n *         address is null\n */\nvar createContactAddress = function(type, bbAddress) {\n\n    if (!bbAddress) {\n        return null;\n    }\n\n    var address1 = bbAddress.address1 || \"\";\n    var address2 = bbAddress.address2 || \"\";\n    var streetAddress = address1 + \", \" + address2;\n    var locality = bbAddress.city || \"\";\n    var region = bbAddress.stateProvince || \"\";\n    var postalCode = bbAddress.zipPostal || \"\";\n    var country = bbAddress.country || \"\";\n    var formatted = streetAddress + \", \" + locality + \", \" + region + \", \" + postalCode + \", \" + country;\n\n    return new ContactAddress(null, type, formatted, streetAddress, locality,\n            region, postalCode, country);\n};\n\nmodule.exports = {\n    /**\n     * Builds a BlackBerry filter expression for contact search using the\n     * contact fields and search filter provided.\n     *\n     * @param {String[]}\n     *            fields Array of Contact fields to search\n     * @param {String}\n     *            filter Filter, or search string\n     * @return filter expression or null if fields is empty or filter is null or\n     *         empty\n     */\n    buildFilterExpression : function(fields, filter) {\n\n        // ensure filter exists\n        if (!filter || filter === \"\") {\n            return null;\n        }\n\n        if (fields.length == 1 && fields[0] === \"*\") {\n            // Cordova enhancement to allow fields value of [\"*\"] to indicate\n            // all supported fields.\n            fields = allFields;\n        }\n\n        // BlackBerry API uses specific operators to build filter expressions\n        // for\n        // querying Contact lists. The operators are\n        // [\"!=\",\"==\",\"<\",\">\",\"<=\",\">=\"].\n        // Use of regex is also an option, and the only one we can use to\n        // simulate\n        // an SQL '%LIKE%' clause.\n        //\n        // Note: The BlackBerry regex implementation doesn't seem to support\n        // conventional regex switches that would enable a case insensitive\n        // search.\n        // It does not honor the (?i) switch (which causes Contact.find() to\n        // fail).\n        // We need case INsensitivity to match the W3C Contacts API spec.\n        // So the guys at RIM proposed this method:\n        //\n        // original filter = \"norm\"\n        // case insensitive filter = \"[nN][oO][rR][mM]\"\n        //\n        var ciFilter = \"\";\n        for ( var i = 0; i < filter.length; i++) {\n            ciFilter = ciFilter + \"[\" + filter[i].toLowerCase() + filter[i].toUpperCase() + \"]\";\n        }\n\n        // match anything that contains our filter string\n        filter = \".*\" + ciFilter + \".*\";\n\n        // build a filter expression using all Contact fields provided\n        var filterExpression = null;\n        if (fields && utils.isArray(fields)) {\n            var fe = null;\n            for (var f = 0; f < fields.length; f++) {\n                if (!fields[f]) {\n                    continue;\n                }\n\n                // retrieve the BlackBerry contact fields that map to the one\n                // specified\n                var bbFields = fieldMappings[fields[f]];\n\n                // BlackBerry doesn't support the field specified\n                if (!bbFields) {\n                    continue;\n                }\n\n                if (!utils.isArray(bbFields)) {\n                    bbFields = [bbFields];\n                }\n\n                // construct the filter expression using the BlackBerry fields\n                for (var j = 0; j < bbFields.length; j++) {\n                    fe = new blackberry.find.FilterExpression(bbFields[j],\n                            \"REGEX\", filter);\n                    if (filterExpression === null) {\n                        filterExpression = fe;\n                    } else {\n                        // combine the filters\n                        filterExpression = new blackberry.find.FilterExpression(\n                                filterExpression, \"OR\", fe);\n                    }\n                }\n            }\n        }\n\n        return filterExpression;\n    },\n\n    /**\n     * Creates a Contact object from a BlackBerry Contact object, copying only\n     * the fields specified.\n     *\n     * This is intended as a privately used function but it is made globally\n     * available so that a Contact.save can convert a BlackBerry contact object\n     * into its W3C equivalent.\n     *\n     * @param {blackberry.pim.Contact}\n     *            bbContact BlackBerry Contact object\n     * @param {String[]}\n     *            fields array of contact fields that should be copied\n     * @return {Contact} a contact object containing the specified fields or\n     *         null if the specified contact is null\n     */\n    createContact : function(bbContact, fields) {\n\n        if (!bbContact) {\n            return null;\n        }\n\n        // construct a new contact object\n        // always copy the contact id and displayName fields\n        var contact = new Contact(bbContact.uid, bbContact.user1);\n\n        // nothing to do\n        if (!fields || !(utils.isArray(fields)) || fields.length === 0) {\n            return contact;\n        } else if (fields.length == 1 && fields[0] === \"*\") {\n            // Cordova enhancement to allow fields value of [\"*\"] to indicate\n            // all supported fields.\n            fields = allFields;\n        }\n\n        // add the fields specified\n        for (var i = 0; i < fields.length; i++) {\n            var field = fields[i];\n\n            if (!field) {\n                continue;\n            }\n\n            // name\n            if (field.indexOf('name') === 0) {\n                var formattedName = bbContact.title + ' ' + bbContact.firstName + ' ' + bbContact.lastName;\n                contact.name = new ContactName(formattedName,\n                        bbContact.lastName, bbContact.firstName, null,\n                        bbContact.title, null);\n            }\n            // phone numbers\n            else if (field.indexOf('phoneNumbers') === 0) {\n                var phoneNumbers = [];\n                if (bbContact.homePhone) {\n                    phoneNumbers.push(new ContactField('home',\n                            bbContact.homePhone));\n                }\n                if (bbContact.homePhone2) {\n                    phoneNumbers.push(new ContactField('home',\n                            bbContact.homePhone2));\n                }\n                if (bbContact.workPhone) {\n                    phoneNumbers.push(new ContactField('work',\n                            bbContact.workPhone));\n                }\n                if (bbContact.workPhone2) {\n                    phoneNumbers.push(new ContactField('work',\n                            bbContact.workPhone2));\n                }\n                if (bbContact.mobilePhone) {\n                    phoneNumbers.push(new ContactField('mobile',\n                            bbContact.mobilePhone));\n                }\n                if (bbContact.faxPhone) {\n                    phoneNumbers.push(new ContactField('fax',\n                            bbContact.faxPhone));\n                }\n                if (bbContact.pagerPhone) {\n                    phoneNumbers.push(new ContactField('pager',\n                            bbContact.pagerPhone));\n                }\n                if (bbContact.otherPhone) {\n                    phoneNumbers.push(new ContactField('other',\n                            bbContact.otherPhone));\n                }\n                contact.phoneNumbers = phoneNumbers.length > 0 ? phoneNumbers\n                        : null;\n            }\n            // emails\n            else if (field.indexOf('emails') === 0) {\n                var emails = [];\n                if (bbContact.email1) {\n                    emails.push(new ContactField(null, bbContact.email1, null));\n                }\n                if (bbContact.email2) {\n                    emails.push(new ContactField(null, bbContact.email2, null));\n                }\n                if (bbContact.email3) {\n                    emails.push(new ContactField(null, bbContact.email3, null));\n                }\n                contact.emails = emails.length > 0 ? emails : null;\n            }\n            // addresses\n            else if (field.indexOf('addresses') === 0) {\n                var addresses = [];\n                if (bbContact.homeAddress) {\n                    addresses.push(createContactAddress(\"home\",\n                            bbContact.homeAddress));\n                }\n                if (bbContact.workAddress) {\n                    addresses.push(createContactAddress(\"work\",\n                            bbContact.workAddress));\n                }\n                contact.addresses = addresses.length > 0 ? addresses : null;\n            }\n            // birthday\n            else if (field.indexOf('birthday') === 0) {\n                if (bbContact.birthday) {\n                    contact.birthday = bbContact.birthday;\n                }\n            }\n            // note\n            else if (field.indexOf('note') === 0) {\n                if (bbContact.note) {\n                    contact.note = bbContact.note;\n                }\n            }\n            // organizations\n            else if (field.indexOf('organizations') === 0) {\n                var organizations = [];\n                if (bbContact.company || bbContact.jobTitle) {\n                    organizations.push(new ContactOrganization(null, null,\n                            bbContact.company, null, bbContact.jobTitle));\n                }\n                contact.organizations = organizations.length > 0 ? organizations\n                        : null;\n            }\n            // categories\n            else if (field.indexOf('categories') === 0) {\n                if (bbContact.categories && bbContact.categories.length > 0) {\n                    contact.categories = bbContact.categories;\n                } else {\n                    contact.categories = null;\n                }\n            }\n            // urls\n            else if (field.indexOf('urls') === 0) {\n                var urls = [];\n                if (bbContact.webpage) {\n                    urls.push(new ContactField(null, bbContact.webpage));\n                }\n                contact.urls = urls.length > 0 ? urls : null;\n            }\n            // photos\n            else if (field.indexOf('photos') === 0) {\n                var photos = [];\n                // The BlackBerry Contact object will have a picture attribute\n                // with Base64 encoded image\n                if (bbContact.picture) {\n                    photos.push(new ContactField('base64', bbContact.picture));\n                }\n                contact.photos = photos.length > 0 ? photos : null;\n            }\n        }\n\n        return contact;\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/ContactUtils.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/ContactUtils.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/DirectoryEntry\", function(require, exports, module) {\n\nvar DirectoryEntry = require('cordova/plugin/DirectoryEntry'),\n    FileEntry = require('cordova/plugin/FileEntry'),\n    FileError = require('cordova/plugin/FileError'),\n    exec = require('cordova/exec');\n\nmodule.exports = {\n    /**\n     * Creates or looks up a directory; override for BlackBerry.\n     *\n     * @param path\n     *            {DOMString} either a relative or absolute path from this\n     *            directory in which to look up or create a directory\n     * @param options\n     *            {Flags} options to create or exclusively create the directory\n     * @param successCallback\n     *            {Function} called with the new DirectoryEntry\n     * @param errorCallback\n     *            {Function} called with a FileError\n     */\n    getDirectory : function(path, options, successCallback, errorCallback) {\n        // create directory if it doesn't exist\n        var create = (options && options.create === true) ? true : false,\n        // if true, causes failure if create is true and path already exists\n        exclusive = (options && options.exclusive === true) ? true : false,\n        // directory exists\n        exists,\n        // create a new DirectoryEntry object and invoke success callback\n        createEntry = function() {\n            var path_parts = path.split('/'),\n                name = path_parts[path_parts.length - 1],\n                dirEntry = new DirectoryEntry(name, path);\n\n            // invoke success callback\n            if (typeof successCallback === 'function') {\n                successCallback(dirEntry);\n            }\n        };\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // determine if path is relative or absolute\n        if (!path) {\n            fail(FileError.ENCODING_ERR);\n            return;\n        } else if (path.indexOf(this.fullPath) !== 0) {\n            // path does not begin with the fullPath of this directory\n            // therefore, it is relative\n            path = this.fullPath + '/' + path;\n        }\n\n        // determine if directory exists\n        try {\n            // will return true if path exists AND is a directory\n            exists = blackberry.io.dir.exists(path);\n        } catch (e) {\n            // invalid path\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        // path is a directory\n        if (exists) {\n            if (create && exclusive) {\n                // can't guarantee exclusivity\n                fail(FileError.PATH_EXISTS_ERR);\n            } else {\n                // create entry for existing directory\n                createEntry();\n            }\n        }\n        // will return true if path exists AND is a file\n        else if (blackberry.io.file.exists(path)) {\n            // the path is a file\n            fail(FileError.TYPE_MISMATCH_ERR);\n        }\n        // path does not exist, create it\n        else if (create) {\n            try {\n                // directory path must have trailing slash\n                var dirPath = path;\n                if (dirPath.substr(-1) !== '/') {\n                    dirPath += '/';\n                }\n                blackberry.io.dir.createNewDir(dirPath);\n                createEntry();\n            } catch (eone) {\n                // unable to create directory\n                fail(FileError.NOT_FOUND_ERR);\n            }\n        }\n        // path does not exist, don't create\n        else {\n            // directory doesn't exist\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    },\n    /**\n     * Create or look up a file.\n     *\n     * @param path {DOMString}\n     *            either a relative or absolute path from this directory in\n     *            which to look up or create a file\n     * @param options {Flags}\n     *            options to create or exclusively create the file\n     * @param successCallback {Function}\n     *            called with the new FileEntry object\n     * @param errorCallback {Function}\n     *            called with a FileError object if error occurs\n     */\n    getFile:function(path, options, successCallback, errorCallback) {\n        // create file if it doesn't exist\n        var create = (options && options.create === true) ? true : false,\n            // if true, causes failure if create is true and path already exists\n            exclusive = (options && options.exclusive === true) ? true : false,\n            // file exists\n            exists,\n            // create a new FileEntry object and invoke success callback\n            createEntry = function() {\n                var path_parts = path.split('/'),\n                    name = path_parts[path_parts.length - 1],\n                    fileEntry = new FileEntry(name, path);\n\n                // invoke success callback\n                if (typeof successCallback === 'function') {\n                    successCallback(fileEntry);\n                }\n            };\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // determine if path is relative or absolute\n        if (!path) {\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n        else if (path.indexOf(this.fullPath) !== 0) {\n            // path does not begin with the fullPath of this directory\n            // therefore, it is relative\n            path = this.fullPath + '/' + path;\n        }\n\n        // determine if file exists\n        try {\n            // will return true if path exists AND is a file\n            exists = blackberry.io.file.exists(path);\n        }\n        catch (e) {\n            // invalid path\n            fail(FileError.ENCODING_ERR);\n            return;\n        }\n\n        // path is a file\n        if (exists) {\n            if (create && exclusive) {\n                // can't guarantee exclusivity\n                fail(FileError.PATH_EXISTS_ERR);\n            }\n            else {\n                // create entry for existing file\n                createEntry();\n            }\n        }\n        // will return true if path exists AND is a directory\n        else if (blackberry.io.dir.exists(path)) {\n            // the path is a directory\n            fail(FileError.TYPE_MISMATCH_ERR);\n        }\n        // path does not exist, create it\n        else if (create) {\n            // create empty file\n            exec(\n                function(result) {\n                    // file created\n                    createEntry();\n                },\n                fail, \"File\", \"write\", [ path, \"\", 0 ]);\n        }\n        // path does not exist, don't create\n        else {\n            // file doesn't exist\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    },\n\n    /**\n     * Delete a directory and all of it's contents.\n     *\n     * @param successCallback {Function} called with no parameters\n     * @param errorCallback {Function} called with a FileError\n     */\n    removeRecursively : function(successCallback, errorCallback) {\n        // we're removing THIS directory\n        var path = this.fullPath;\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // attempt to delete directory\n        if (blackberry.io.dir.exists(path)) {\n            // it is an error to attempt to remove the file system root\n            if (exec(null, null, \"File\", \"isFileSystemRoot\", [ path ]) === true) {\n                fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n            }\n            else {\n                try {\n                    // delete the directory, setting recursive flag to true\n                    blackberry.io.dir.deleteDirectory(path, true);\n                    if (typeof successCallback === \"function\") {\n                        successCallback();\n                    }\n                } catch (e) {\n                    // permissions don't allow deletion\n                    console.log(e);\n                    fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                }\n            }\n        }\n        // it's a file, not a directory\n        else if (blackberry.io.file.exists(path)) {\n            fail(FileError.TYPE_MISMATCH_ERR);\n        }\n        // not found\n        else {\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/DirectoryEntry.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/DirectoryEntry.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/Entry\", function(require, exports, module) {\n\nvar FileError = require('cordova/plugin/FileError'),\n    LocalFileSystem = require('cordova/plugin/LocalFileSystem'),\n    resolveLocalFileSystemURI = require('cordova/plugin/resolveLocalFileSystemURI'),\n    requestFileSystem = require('cordova/plugin/requestFileSystem'),\n    exec = require('cordova/exec');\n\nmodule.exports = {\n    remove : function(successCallback, errorCallback) {\n        var path = this.fullPath,\n            // directory contents\n            contents = [];\n\n        var fail = function(error) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(error));\n            }\n        };\n\n        // file\n        if (blackberry.io.file.exists(path)) {\n            try {\n                blackberry.io.file.deleteFile(path);\n                if (typeof successCallback === \"function\") {\n                    successCallback();\n                }\n            } catch (e) {\n                // permissions don't allow\n                fail(FileError.INVALID_MODIFICATION_ERR);\n            }\n        }\n        // directory\n        else if (blackberry.io.dir.exists(path)) {\n            // it is an error to attempt to remove the file system root\n            if (exec(null, null, \"File\", \"isFileSystemRoot\", [ path ]) === true) {\n                fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n            } else {\n                // check to see if directory is empty\n                contents = blackberry.io.dir.listFiles(path);\n                if (contents.length !== 0) {\n                    fail(FileError.INVALID_MODIFICATION_ERR);\n                } else {\n                    try {\n                        // delete\n                        blackberry.io.dir.deleteDirectory(path, false);\n                        if (typeof successCallback === \"function\") {\n                            successCallback();\n                        }\n                    } catch (eone) {\n                        // permissions don't allow\n                        fail(FileError.NO_MODIFICATION_ALLOWED_ERR);\n                    }\n                }\n            }\n        }\n        // not found\n        else {\n            fail(FileError.NOT_FOUND_ERR);\n        }\n    },\n    getParent : function(successCallback, errorCallback) {\n        var that = this;\n\n        try {\n            // On BlackBerry, the TEMPORARY file system is actually a temporary\n            // directory that is created on a per-application basis. This is\n            // to help ensure that applications do not share the same temporary\n            // space. So we check to see if this is the TEMPORARY file system\n            // (directory). If it is, we must return this Entry, rather than\n            // the Entry for its parent.\n            requestFileSystem(LocalFileSystem.TEMPORARY, 0,\n                    function(fileSystem) {\n                        if (fileSystem.root.fullPath === that.fullPath) {\n                            if (typeof successCallback === 'function') {\n                                successCallback(fileSystem.root);\n                            }\n                        } else {\n                            resolveLocalFileSystemURI(blackberry.io.dir\n                                    .getParentDirectory(that.fullPath),\n                                    successCallback, errorCallback);\n                        }\n                    }, errorCallback);\n        } catch (e) {\n            if (typeof errorCallback === 'function') {\n                errorCallback(new FileError(FileError.NOT_FOUND_ERR));\n            }\n        }\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/Entry.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/Entry.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/MediaError\", function(require, exports, module) {\n\n\n// The MediaError object exists on BB OS 6+ which prevents the Cordova version\n// from being defined. This object is used to merge in differences between the BB\n// MediaError object and the Cordova version.\nmodule.exports = {\n        MEDIA_ERR_NONE_ACTIVE : 0,\n        MEDIA_ERR_NONE_SUPPORTED : 4\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/MediaError.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/MediaError.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/app\", function(require, exports, module) {\n\nvar exec = require('cordova/exec'),\n    platform = require('cordova/platform'),\n    manager = require('cordova/plugin/' + platform.runtime() + '/manager');\n\nmodule.exports = {\n  /**\n   * Clear the resource cache.\n   */\n  clearCache:function() {\n      if (typeof blackberry.widgetcache === \"undefined\" || blackberry.widgetcache === null) {\n          console.log(\"blackberry.widgetcache permission not found. Cache clear request denied.\");\n          return;\n      }\n      blackberry.widgetcache.clearAll();\n  },\n\n  /**\n   * Clear web history in this web view.\n   * Instead of BACK button loading the previous web page, it will exit the app.\n   */\n  clearHistory:function() {\n    exec(null, null, \"App\", \"clearHistory\", []);\n  },\n\n  /**\n   * Go to previous page displayed.\n   * This is the same as pressing the backbutton on Android device.\n   */\n  backHistory:function() {\n    // window.history.back() behaves oddly on BlackBerry, so use\n    // native implementation.\n    exec(null, null, \"App\", \"backHistory\", []);\n  },\n\n  /**\n   * Exit and terminate the application.\n   */\n  exitApp:function() {\n      // Call onunload if it is defined since BlackBerry does not invoke\n      // on application exit.\n      if (typeof window.onunload === \"function\") {\n          window.onunload();\n      }\n\n      // allow Cordova JavaScript Extension opportunity to cleanup\n      manager.destroy();\n\n      // exit the app\n      blackberry.app.exit();\n  }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/app.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/app.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/app/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.clobbers('cordova/plugin/java/app', 'navigator.app');\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/app/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/app/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/contacts\", function(require, exports, module) {\n\nvar ContactError = require('cordova/plugin/ContactError'),\n    utils = require('cordova/utils'),\n    ContactUtils = require('cordova/plugin/java/ContactUtils');\n\nmodule.exports = {\n    /**\n     * Returns an array of Contacts matching the search criteria.\n     *\n     * @return array of Contacts matching search criteria\n     */\n    find : function(fields, success, fail, options) {\n        // Success callback is required. Throw exception if not specified.\n        if (typeof success !== 'function') {\n            throw new TypeError(\n                    \"You must specify a success callback for the find command.\");\n        }\n\n        // Search qualifier is required and cannot be empty.\n        if (!fields || !(utils.isArray(fields)) || fields.length === 0) {\n            if (typeof fail == 'function') {\n                fail(new ContactError(ContactError.INVALID_ARGUMENT_ERROR));\n            }\n            return;\n        }\n\n        // default is to return a single contact match\n        var numContacts = 1;\n\n        // search options\n        var filter = null;\n        if (options) {\n            // return multiple objects?\n            if (options.multiple === true) {\n                // -1 on BlackBerry will return all contact matches.\n                numContacts = -1;\n            }\n            filter = options.filter;\n        }\n\n        // build the filter expression to use in find operation\n        var filterExpression = ContactUtils.buildFilterExpression(fields, filter);\n\n        // find matching contacts\n        // Note: the filter expression can be null here, in which case, the find\n        // won't filter\n        var bbContacts = blackberry.pim.Contact.find(filterExpression, null, numContacts);\n\n        // convert to Contact from blackberry.pim.Contact\n        var contacts = [];\n        for (var i = 0; i < bbContacts.length; i++) {\n            if (bbContacts[i]) {\n                // W3C Contacts API specification states that only the fields\n                // in the search filter should be returned, so we create\n                // a new Contact object, copying only the fields specified\n                contacts.push(ContactUtils.createContact(bbContacts[i], fields));\n            }\n        }\n\n        // return results\n        success(contacts);\n    }\n\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/contacts.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/contacts.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/contacts/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.merges('cordova/plugin/java/contacts', 'navigator.contacts');\nmodulemapper.merges('cordova/plugin/java/Contact', 'Contact');\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/contacts/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/contacts/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/file/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.clobbers('cordova/plugin/File', 'File');\nmodulemapper.merges('cordova/plugin/java/DirectoryEntry', 'DirectoryEntry');\nmodulemapper.merges('cordova/plugin/java/Entry', 'Entry');\n\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/file/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/file/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/manager\", function(require, exports, module) {\n\nvar cordova = require('cordova');\n\nfunction _exec(win, fail, clazz, action, args) {\n    var callbackId = clazz + cordova.callbackId++,\n        origResult,\n        evalResult,\n        execResult;\n\n    try {\n        if (win || fail) {\n            cordova.callbacks[callbackId] = {success: win, fail: fail};\n        }\n\n        // Note: Device returns string, but for some reason emulator returns object - so convert to string.\n        origResult = \"\" + org.apache.cordova.JavaPluginManager.exec(clazz, action, callbackId, JSON.stringify(args), true);\n\n        // If a result was returned\n        if (origResult.length > 0) {\n            evalResult = JSON.parse(origResult);\n\n            // If status is OK, then return evalResult value back to caller\n            if (evalResult.status === cordova.callbackStatus.OK) {\n\n                // If there is a success callback, then call it now with returned evalResult value\n                if (win) {\n                    // Clear callback if not expecting any more results\n                    if (!evalResult.keepCallback) {\n                        delete cordova.callbacks[callbackId];\n                    }\n                }\n            } else if (evalResult.status === cordova.callbackStatus.NO_RESULT) {\n\n                // Clear callback if not expecting any more results\n                if (!evalResult.keepCallback) {\n                    delete cordova.callbacks[callbackId];\n                }\n            } else {\n                // If there is a fail callback, then call it now with returned evalResult value\n                if (fail) {\n\n                    // Clear callback if not expecting any more results\n                    if (!evalResult.keepCallback) {\n                        delete cordova.callbacks[callbackId];\n                    }\n                }\n            }\n            execResult = evalResult;\n        } else {\n            // Asynchronous calls return an empty string. Return a NO_RESULT\n            // status for those executions.\n            execResult = {\"status\" : cordova.callbackStatus.NO_RESULT,\n                    \"message\" : \"\"};\n        }\n    } catch (e) {\n        console.log(\"BlackBerryPluginManager Error: \" + e);\n        execResult = {\"status\" : cordova.callbackStatus.ERROR,\n                      \"message\" : e.message};\n    }\n\n    return execResult;\n}\n\nmodule.exports = {\n    exec: function (win, fail, clazz, action, args) {\n        return _exec(win, fail, clazz, action, args);\n    },\n    resume: org.apache.cordova.JavaPluginManager.resume,\n    pause: org.apache.cordova.JavaPluginManager.pause,\n    destroy: org.apache.cordova.JavaPluginManager.destroy\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/manager.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/manager.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/media/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.defaults('cordova/plugin/Media', 'Media');\nmodulemapper.defaults('cordova/plugin/MediaError', 'MediaError');\n// Exists natively on BB OS 6+, merge in Cordova specifics\nmodulemapper.merges('cordova/plugin/java/MediaError', 'MediaError');\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/media/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/media/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/notification\", function(require, exports, module) {\n\nvar exec = require('cordova/exec');\n\n/**\n * Provides BlackBerry enhanced notification API.\n */\nmodule.exports = {\n    activityStart : function(title, message) {\n        // If title and message not specified then mimic Android behavior of\n        // using default strings.\n        if (typeof title === \"undefined\" && typeof message == \"undefined\") {\n            title = \"Busy\";\n            message = 'Please wait...';\n        }\n\n        exec(null, null, 'Notification', 'activityStart', [ title, message ]);\n    },\n\n    /**\n     * Close an activity dialog\n     */\n    activityStop : function() {\n        exec(null, null, 'Notification', 'activityStop', []);\n    },\n\n    /**\n     * Display a progress dialog with progress bar that goes from 0 to 100.\n     *\n     * @param {String}\n     *            title Title of the progress dialog.\n     * @param {String}\n     *            message Message to display in the dialog.\n     */\n    progressStart : function(title, message) {\n        exec(null, null, 'Notification', 'progressStart', [ title, message ]);\n    },\n\n    /**\n     * Close the progress dialog.\n     */\n    progressStop : function() {\n        exec(null, null, 'Notification', 'progressStop', []);\n    },\n\n    /**\n     * Set the progress dialog value.\n     *\n     * @param {Number}\n     *            value 0-100\n     */\n    progressValue : function(value) {\n        exec(null, null, 'Notification', 'progressValue', [ value ]);\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/notification.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/notification.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/notification/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.merges('cordova/plugin/java/notification', 'navigator.notification');\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/notification/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/notification/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/java/platform\", function(require, exports, module) {\n\nmodule.exports = {\n    id: \"blackberry\",\n    initialize:function() {\n        var cordova = require('cordova'),\n            exec = require('cordova/exec'),\n            channel = require('cordova/channel'),\n            platform = require('cordova/platform'),\n            manager = require('cordova/plugin/' + platform.runtime() + '/manager'),\n            app = require('cordova/plugin/java/app');\n\n        // BB OS 5 does not define window.console.\n        if (typeof window.console === 'undefined') {\n            window.console = {};\n        }\n\n        // Override console.log with native logging ability.\n        // BB OS 7 devices define console.log for use with web inspector\n        // debugging. If console.log is already defined, invoke it in addition\n        // to native logging.\n        var origLog = window.console.log;\n        window.console.log = function(msg) {\n            if (typeof origLog === 'function') {\n                origLog.call(window.console, msg);\n            }\n            org.apache.cordova.Logger.log(''+msg);\n        };\n\n        // Mapping of button events to BlackBerry key identifier.\n        var buttonMapping = {\n            'backbutton'         : blackberry.system.event.KEY_BACK,\n            'conveniencebutton1' : blackberry.system.event.KEY_CONVENIENCE_1,\n            'conveniencebutton2' : blackberry.system.event.KEY_CONVENIENCE_2,\n            'endcallbutton'      : blackberry.system.event.KEY_ENDCALL,\n            'menubutton'         : blackberry.system.event.KEY_MENU,\n            'startcallbutton'    : blackberry.system.event.KEY_STARTCALL,\n            'volumedownbutton'   : blackberry.system.event.KEY_VOLUMEDOWN,\n            'volumeupbutton'     : blackberry.system.event.KEY_VOLUMEUP\n        };\n\n        // Generates a function which fires the specified event.\n        var fireEvent = function(event) {\n            return function() {\n                cordova.fireDocumentEvent(event, null);\n            };\n        };\n\n        var eventHandler = function(event) {\n            return function() {\n                // If we just attached the first handler, let native know we\n                // need to override the hardware button.\n                if (this.numHandlers) {\n                    blackberry.system.event.onHardwareKey(\n                            buttonMapping[event], fireEvent(event));\n                }\n                // If we just detached the last handler, let native know we\n                // no longer override the hardware button.\n                else {\n                    blackberry.system.event.onHardwareKey(\n                            buttonMapping[event], null);\n                }\n            };\n        };\n\n        // Inject listeners for buttons on the document.\n        for (var button in buttonMapping) {\n            if (buttonMapping.hasOwnProperty(button)) {\n                var buttonChannel = cordova.addDocumentEventHandler(button);\n                buttonChannel.onHasSubscribersChange = eventHandler(button);\n            }\n        }\n\n        // Fires off necessary code to pause/resume app\n        var resume = function() {\n            cordova.fireDocumentEvent('resume');\n            manager.resume();\n        };\n        var pause = function() {\n            cordova.fireDocumentEvent('pause');\n            manager.pause();\n        };\n\n        /************************************************\n         * Patch up the generic pause/resume listeners. *\n         ************************************************/\n\n        // Unsubscribe handler - turns off native backlight change\n        // listener\n        var onHasSubscribersChange = function() {\n            // If we just attached the first handler and there are\n            // no pause handlers, start the backlight system\n            // listener on the native side.\n            if (this.numHandlers && (channel.onResume.numHandlers + channel.onPause.numHandlers === 1)) {\n                exec(backlightWin, backlightFail, \"App\", \"detectBacklight\", []);\n            } else if (channel.onResume.numHandlers === 0 && channel.onPause.numHandlers === 0) {\n                exec(null, null, 'App', 'ignoreBacklight', []);\n            }\n        };\n\n        // Native backlight detection win/fail callbacks\n        var backlightWin = function(isOn) {\n            if (isOn === true) {\n                resume();\n            } else {\n                pause();\n            }\n        };\n        var backlightFail = function(e) {\n            console.log(\"Error detecting backlight on/off.\");\n        };\n\n        // Override stock resume and pause listeners so we can trigger\n        // some native methods during attach/remove\n        channel.onResume = cordova.addDocumentEventHandler('resume');\n        channel.onResume.onHasSubscribersChange = onHasSubscribersChange;\n        channel.onPause = cordova.addDocumentEventHandler('pause');\n        channel.onPause.onHasSubscribersChange = onHasSubscribersChange;\n\n        // Fire resume event when application brought to foreground.\n        blackberry.app.event.onForeground(resume);\n\n        // Fire pause event when application sent to background.\n        blackberry.app.event.onBackground(pause);\n\n        // Trap BlackBerry WebWorks exit. Allow plugins to clean up before exiting.\n        blackberry.app.event.onExit(app.exitApp);\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/java/platform.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/java/platform.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/qnx/compass/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.merges('cordova/plugin/qnx/compass', 'navigator.compass');\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/qnx/compass/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/qnx/compass/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/qnx/inappbrowser/bbsymbols\", function(require, exports, module) {\n\n\nvar modulemapper = require('cordova/modulemapper');\n\nmodulemapper.clobbers('cordova/plugin/InAppBrowser', 'open');\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/qnx/inappbrowser/bbsymbols.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/qnx/inappbrowser/bbsymbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/webworks/accelerometer\", function(require, exports, module) {\n\nvar cordova = require('cordova'),\n    callback;\n\nmodule.exports = {\n    start: function (args, win, fail) {\n        window.removeEventListener(\"devicemotion\", callback);\n        callback = function (motion) {\n            win({\n                x: motion.accelerationIncludingGravity.x,\n                y: motion.accelerationIncludingGravity.y,\n                z: motion.accelerationIncludingGravity.z,\n                timestamp: motion.timestamp\n            });\n        };\n        window.addEventListener(\"devicemotion\", callback);\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    },\n    stop: function (args, win, fail) {\n        window.removeEventListener(\"devicemotion\", callback);\n        return { \"status\" : cordova.callbackStatus.OK, \"message\" : \"removed\" };\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/webworks/accelerometer.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/webworks/accelerometer.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/webworks/logger\", function(require, exports, module) {\n\nvar cordova = require('cordova');\n\nmodule.exports = {\n    log: function (args, win, fail) {\n        console.log(args);\n        return {\"status\" : cordova.callbackStatus.OK,\n                \"message\" : 'Message logged to console: ' + args};\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/webworks/logger.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/webworks/logger.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/webworks/media\", function(require, exports, module) {\n\nvar cordova = require('cordova'),\n    audioObjects = {};\n\nmodule.exports = {\n    create: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            src = args[1];\n\n        if (typeof src == \"undefined\"){\n            audioObjects[id] = new Audio();\n        } else {\n            audioObjects[id] = new Audio(src);\n        }\n\n        return {\"status\" : 1, \"message\" : \"Audio object created\" };\n    },\n    startPlayingAudio: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            audio = audioObjects[id],\n            result;\n\n        if (args.length === 1 || typeof args[1] == \"undefined\" ) {\n            return {\"status\" : 9, \"message\" : \"Media source argument not found\"};\n        }\n\n        if (audio) {\n            audio.pause();\n            audioObjects[id] = undefined;\n        }\n\n        audio = audioObjects[id] = new Audio(args[1]);\n        audio.play();\n        return {\"status\" : 1, \"message\" : \"Audio play started\" };\n    },\n    stopPlayingAudio: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            audio = audioObjects[id],\n            result;\n\n        if (!audio) {\n            return {\"status\" : 2, \"message\" : \"Audio Object has not been initialized\"};\n        }\n\n        audio.pause();\n        audioObjects[id] = undefined;\n\n        return {\"status\" : 1, \"message\" : \"Audio play stopped\" };\n    },\n    seekToAudio: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            audio = audioObjects[id],\n            result;\n\n        if (!audio) {\n            result = {\"status\" : 2, \"message\" : \"Audio Object has not been initialized\"};\n        } else if (args.length === 1) {\n            result = {\"status\" : 9, \"message\" : \"Media seek time argument not found\"};\n        } else {\n            try {\n                audio.currentTime = args[1];\n            } catch (e) {\n                console.log('Error seeking audio: ' + e);\n                return {\"status\" : 3, \"message\" : \"Error seeking audio: \" + e};\n            }\n\n            result = {\"status\" : 1, \"message\" : \"Seek to audio succeeded\" };\n        }\n        return result;\n    },\n    pausePlayingAudio: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            audio = audioObjects[id],\n            result;\n\n        if (!audio) {\n            return {\"status\" : 2, \"message\" : \"Audio Object has not been initialized\"};\n        }\n\n        audio.pause();\n\n        return {\"status\" : 1, \"message\" : \"Audio paused\" };\n    },\n    getCurrentPositionAudio: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            audio = audioObjects[id],\n            result;\n\n        if (!audio) {\n            return {\"status\" : 2, \"message\" : \"Audio Object has not been initialized\"};\n        }\n\n        return {\"status\" : 1, \"message\" : audio.currentTime };\n    },\n    getDuration: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            audio = audioObjects[id],\n            result;\n\n        if (!audio) {\n            return {\"status\" : 2, \"message\" : \"Audio Object has not been initialized\"};\n        }\n\n        return {\"status\" : 1, \"message\" : audio.duration };\n    },\n    startRecordingAudio: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        if (args.length <= 1) {\n            return {\"status\" : 9, \"message\" : \"Media start recording, insufficient arguments\"};\n        }\n\n        blackberry.media.microphone.record(args[1], win, fail);\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    },\n    stopRecordingAudio: function (args, win, fail) {\n    },\n    release: function (args, win, fail) {\n        if (!args.length) {\n            return {\"status\" : 9, \"message\" : \"Media Object id was not sent in arguments\"};\n        }\n\n        var id = args[0],\n            audio = audioObjects[id],\n            result;\n\n        if (audio) {\n            if(audio.src !== \"\"){\n                audio.src = undefined;\n            }\n            audioObjects[id] = undefined;\n            //delete audio;\n        }\n\n        result = {\"status\" : 1, \"message\" : \"Media resources released\"};\n\n        return result;\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/webworks/media.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/webworks/media.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/plugin/webworks/notification\", function(require, exports, module) {\n\nvar cordova = require('cordova');\n\nmodule.exports = {\n    alert: function (args, win, fail) {\n        if (args.length !== 3) {\n            return {\"status\" : 9, \"message\" : \"Notification action - alert arguments not found\"};\n        }\n\n        //Unpack and map the args\n        var msg = args[0],\n            title = args[1],\n            btnLabel = args[2];\n\n        blackberry.ui.dialog.customAskAsync.apply(this, [ msg, [ btnLabel ], win, { \"title\" : title } ]);\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    },\n    confirm: function (args, win, fail) {\n        if (args.length !== 3) {\n            return {\"status\" : 9, \"message\" : \"Notification action - confirm arguments not found\"};\n        }\n\n        //Unpack and map the args\n        var msg = args[0],\n            title = args[1],\n            btnLabel = args[2],\n            btnLabels = btnLabel.split(\",\");\n\n        blackberry.ui.dialog.customAskAsync.apply(this, [msg, btnLabels, win, {\"title\" : title} ]);\n        return { \"status\" : cordova.callbackStatus.NO_RESULT, \"message\" : \"WebWorks Is On It\" };\n    }\n};\n\n});\n\n//@ sourceURL=lib/blackberry/plugin/webworks/notification.js")} catch(e) {console.log("exception: in lib/blackberry/plugin/webworks/notification.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/pluginloader\", function(require, exports, module) {\n\nvar channel = require('cordova/channel');\nvar modulemapper = require('cordova/modulemapper');\n\n// Helper function to inject a <script> tag.\nfunction injectScript(url, onload, onerror) {\n    var script = document.createElement(\"script\");\n    // onload fires even when script fails loads with an error.\n    script.onload = onload;\n    script.onerror = onerror || onload;\n    script.src = url;\n    document.head.appendChild(script);\n}\n\nfunction onScriptLoadingComplete(moduleList) {\n    // Loop through all the plugins and then through their clobbers and merges.\n    for (var i = 0, module; module = moduleList[i]; i++) {\n        if (module) {\n            try {\n                if (module.clobbers && module.clobbers.length) {\n                    for (var j = 0; j < module.clobbers.length; j++) {\n                        modulemapper.clobbers(module.id, module.clobbers[j]);\n                    }\n                }\n\n                if (module.merges && module.merges.length) {\n                    for (var k = 0; k < module.merges.length; k++) {\n                        modulemapper.merges(module.id, module.merges[k]);\n                    }\n                }\n\n                // Finally, if runs is truthy we want to simply require() the module.\n                // This can be skipped if it had any merges or clobbers, though,\n                // since the mapper will already have required the module.\n                if (module.runs && !(module.clobbers && module.clobbers.length) && !(module.merges && module.merges.length)) {\n                    modulemapper.runs(module.id);\n                }\n            }\n            catch(err) {\n                // error with module, most likely clobbers, should we continue?\n            }\n        }\n    }\n\n    finishPluginLoading();\n}\n\n// Called when:\n// * There are plugins defined and all plugins are finished loading.\n// * There are no plugins to load.\nfunction finishPluginLoading() {\n    channel.onPluginsReady.fire();\n}\n\n// Handler for the cordova_plugins.js content.\n// See plugman's plugin_loader.js for the details of this object.\n// This function is only called if the really is a plugins array that isn't empty.\n// Otherwise the onerror response handler will just call finishPluginLoading().\nfunction handlePluginsObject(path, moduleList) {\n    // Now inject the scripts.\n    var scriptCounter = moduleList.length;\n\n    if (!scriptCounter) {\n        finishPluginLoading();\n        return;\n    }\n    function scriptLoadedCallback() {\n        if (!--scriptCounter) {\n            onScriptLoadingComplete(moduleList);\n        }\n    }\n\n    for (var i = 0; i < moduleList.length; i++) {\n        injectScript(path + moduleList[i].file, scriptLoadedCallback);\n    }\n}\n\nfunction injectPluginScript(pathPrefix) {\n    injectScript(pathPrefix + 'cordova_plugins.js', function(){\n        try {\n            var moduleList = require(\"cordova/plugin_list\");\n            handlePluginsObject(pathPrefix, moduleList);\n        } catch (e) {\n            // Error loading cordova_plugins.js, file not found or something\n            // this is an acceptable error, pre-3.0.0, so we just move on.\n            finishPluginLoading();\n        }\n    },finishPluginLoading); // also, add script load error handler for file not found\n}\n\nfunction findCordovaPath() {\n    var path = null;\n    var scripts = document.getElementsByTagName('script');\n    var term = 'cordova.js';\n    for (var n = scripts.length-1; n>-1; n--) {\n        var src = scripts[n].src;\n        if (src.indexOf(term) == (src.length - term.length)) {\n            path = src.substring(0, src.length - term.length);\n            break;\n        }\n    }\n    return path;\n}\n\n// Tries to load all plugins' js-modules.\n// This is an async process, but onDeviceReady is blocked on onPluginsReady.\n// onPluginsReady is fired when there are no plugins to load, or they are all done.\nexports.load = function() {\n    var pathPrefix = findCordovaPath();\n    if (pathPrefix === null) {\n        console.log('Could not find cordova.js script tag. Plugin loading may fail.');\n        pathPrefix = '';\n    }\n    injectPluginScript(pathPrefix);\n};\n\n\n});\n\n//@ sourceURL=lib/common/pluginloader.js")} catch(e) {console.log("exception: in lib/common/pluginloader.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/symbols\", function(require, exports, module) {\n\nvar modulemapper = require('cordova/modulemapper');\n\n// Use merges here in case others symbols files depend on this running first,\n// but fail to declare the dependency with a require().\nmodulemapper.merges('cordova', 'cordova');\nmodulemapper.clobbers('cordova/exec', 'cordova.exec');\nmodulemapper.clobbers('cordova/exec', 'Cordova.exec');\n\n});\n\n//@ sourceURL=lib/common/symbols.js")} catch(e) {console.log("exception: in lib/common/symbols.js: " + e);console.log(e.stack);}
try {eval("define(\"cordova/utils\", function(require, exports, module) {\n\nvar utils = exports;\n\n/**\n * Defines a property getter / setter for obj[key].\n */\nutils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {\n    if (Object.defineProperty) {\n        var desc = {\n            get: getFunc,\n            configurable: true\n        };\n        if (opt_setFunc) {\n            desc.set = opt_setFunc;\n        }\n        Object.defineProperty(obj, key, desc);\n    } else {\n        obj.__defineGetter__(key, getFunc);\n        if (opt_setFunc) {\n            obj.__defineSetter__(key, opt_setFunc);\n        }\n    }\n};\n\n/**\n * Defines a property getter for obj[key].\n */\nutils.defineGetter = utils.defineGetterSetter;\n\nutils.arrayIndexOf = function(a, item) {\n    if (a.indexOf) {\n        return a.indexOf(item);\n    }\n    var len = a.length;\n    for (var i = 0; i < len; ++i) {\n        if (a[i] == item) {\n            return i;\n        }\n    }\n    return -1;\n};\n\n/**\n * Returns whether the item was found in the array.\n */\nutils.arrayRemove = function(a, item) {\n    var index = utils.arrayIndexOf(a, item);\n    if (index != -1) {\n        a.splice(index, 1);\n    }\n    return index != -1;\n};\n\nutils.typeName = function(val) {\n    return Object.prototype.toString.call(val).slice(8, -1);\n};\n\n/**\n * Returns an indication of whether the argument is an array or not\n */\nutils.isArray = function(a) {\n    return utils.typeName(a) == 'Array';\n};\n\n/**\n * Returns an indication of whether the argument is a Date or not\n */\nutils.isDate = function(d) {\n    return utils.typeName(d) == 'Date';\n};\n\n/**\n * Does a deep clone of the object.\n */\nutils.clone = function(obj) {\n    if(!obj || typeof obj == 'function' || utils.isDate(obj) || typeof obj != 'object') {\n        return obj;\n    }\n\n    var retVal, i;\n\n    if(utils.isArray(obj)){\n        retVal = [];\n        for(i = 0; i < obj.length; ++i){\n            retVal.push(utils.clone(obj[i]));\n        }\n        return retVal;\n    }\n\n    retVal = {};\n    for(i in obj){\n        if(!(i in retVal) || retVal[i] != obj[i]) {\n            retVal[i] = utils.clone(obj[i]);\n        }\n    }\n    return retVal;\n};\n\n/**\n * Returns a wrapped version of the function\n */\nutils.close = function(context, func, params) {\n    if (typeof params == 'undefined') {\n        return function() {\n            return func.apply(context, arguments);\n        };\n    } else {\n        return function() {\n            return func.apply(context, params);\n        };\n    }\n};\n\n/**\n * Create a UUID\n */\nutils.createUUID = function() {\n    return UUIDcreatePart(4) + '-' +\n        UUIDcreatePart(2) + '-' +\n        UUIDcreatePart(2) + '-' +\n        UUIDcreatePart(2) + '-' +\n        UUIDcreatePart(6);\n};\n\n/**\n * Extends a child object from a parent object using classical inheritance\n * pattern.\n */\nutils.extend = (function() {\n    // proxy used to establish prototype chain\n    var F = function() {};\n    // extend Child from Parent\n    return function(Child, Parent) {\n        F.prototype = Parent.prototype;\n        Child.prototype = new F();\n        Child.__super__ = Parent.prototype;\n        Child.prototype.constructor = Child;\n    };\n}());\n\n/**\n * Alerts a message in any available way: alert or console.log.\n */\nutils.alert = function(msg) {\n    if (window.alert) {\n        window.alert(msg);\n    } else if (console && console.log) {\n        console.log(msg);\n    }\n};\n\n\n//------------------------------------------------------------------------------\nfunction UUIDcreatePart(length) {\n    var uuidpart = \"\";\n    for (var i=0; i<length; i++) {\n        var uuidchar = parseInt((Math.random() * 256), 10).toString(16);\n        if (uuidchar.length == 1) {\n            uuidchar = \"0\" + uuidchar;\n        }\n        uuidpart += uuidchar;\n    }\n    return uuidpart;\n}\n\n\n});\n\n//@ sourceURL=lib/common/utils.js")} catch(e) {console.log("exception: in lib/common/utils.js: " + e);console.log(e.stack);}
window.cordova = require('cordova');
try {eval("\n(function (context) {\n    if (context._cordovaJsLoaded) {\n        throw new Error('cordova.js included multiple times.');\n    }\n    context._cordovaJsLoaded = true;\n\n    var channel = require('cordova/channel');\n    var pluginloader = require('cordova/pluginloader');\n\n    var platformInitChannelsArray = [channel.onNativeReady, channel.onPluginsReady];\n\n    function logUnfiredChannels(arr) {\n        for (var i = 0; i < arr.length; ++i) {\n            if (arr[i].state != 2) {\n                console.log('Channel not fired: ' + arr[i].type);\n            }\n        }\n    }\n\n    window.setTimeout(function() {\n        if (channel.onDeviceReady.state != 2) {\n            console.log('deviceready has not fired after 5 seconds.');\n            logUnfiredChannels(platformInitChannelsArray);\n            logUnfiredChannels(channel.deviceReadyChannelsArray);\n        }\n    }, 5000);\n\n    // Replace navigator before any modules are required(), to ensure it happens as soon as possible.\n    // We replace it so that properties that can't be clobbered can instead be overridden.\n    function replaceNavigator(origNavigator) {\n        var CordovaNavigator = function() {};\n        CordovaNavigator.prototype = origNavigator;\n        var newNavigator = new CordovaNavigator();\n        // This work-around really only applies to new APIs that are newer than Function.bind.\n        // Without it, APIs such as getGamepads() break.\n        if (CordovaNavigator.bind) {\n            for (var key in origNavigator) {\n                if (typeof origNavigator[key] == 'function') {\n                    newNavigator[key] = origNavigator[key].bind(origNavigator);\n                }\n            }\n        }\n        return newNavigator;\n    }\n    if (context.navigator) {\n        context.navigator = replaceNavigator(context.navigator);\n    }\n\n    // _nativeReady is global variable that the native side can set\n    // to signify that the native code is ready. It is a global since\n    // it may be called before any cordova JS is ready.\n    if (window._nativeReady) {\n        channel.onNativeReady.fire();\n    }\n\n    /**\n     * Create all cordova objects once native side is ready.\n     */\n    channel.join(function() {\n        // Call the platform-specific initialization\n        require('cordova/platform').initialize();\n\n        // Fire event to notify that all objects are created\n        channel.onCordovaReady.fire();\n\n        // Fire onDeviceReady event once page has fully loaded, all\n        // constructors have run and cordova info has been received from native\n        // side.\n        // This join call is deliberately made after platform.initialize() in\n        // order that plugins may manipulate channel.deviceReadyChannelsArray\n        // if necessary.\n        channel.join(function() {\n            require('cordova').fireDocumentEvent('deviceready');\n        }, channel.deviceReadyChannelsArray);\n\n    }, platformInitChannelsArray);\n\n    // Don't attempt to load when running unit tests.\n    if (typeof XMLHttpRequest != 'undefined') {\n        pluginloader.load();\n    }\n}(window));\n\n//@ sourceURL=lib/scripts/bootstrap.js")} catch(e) {console.log("exception: in lib/scripts/bootstrap.js: " + e);console.log(e.stack);}
try {eval("\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    if (require('cordova/platform').runtime() === 'air') {\n        require('cordova/channel').onNativeReady.fire();\n    }\n});\n\n//@ sourceURL=lib/scripts/bootstrap-blackberry.js")} catch(e) {console.log("exception: in lib/scripts/bootstrap-blackberry.js: " + e);console.log(e.stack);}
})();